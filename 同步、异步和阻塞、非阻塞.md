## 同步、异步和阻塞、非阻塞  
  
> "阻塞" 与 "非阻塞" 和 "同步" 与 "异步" 不能简单的从字面理解，提供一个从分布式系统角度的回答。  
    
### 同步与异步  

> 同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)  
所谓同步，就是在发出一个"调用"时，在没有得到结果之前，该"调用"就不返回。但是一旦调用返回，就得到返回值了。  
换句话说，就是由"调用者"主动等待这个"调用"的结果。  
>  
> 而异步则是相反，"调用"在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在"调用"发出后，"被调用者"通过状态、通知来通知调用者，或通过回调函数处理这个调用。  
>  
> 典型的异步编程模型比如 Node.js  
>  
> 举个通俗的例子：  
你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，"我查一下"，然后开始查啊查，等查好了（可能是 5 秒，也可能是一天）告诉你结果（返回结果）。  
而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过"回电"这种方式来回调。  
      
### 阻塞与非阻塞  
    
> 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.  
阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。  
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。  
>  
> 还是上面的例子，  
你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己"挂起"，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟 check 一下老板有没有返回结果。  
在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。  

### 举个栗子

> 老张爱喝茶，废话不说，煮开水。  
>
> 出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。  
>
> 1 老张把水壶放到火上，立等水开。（同步阻塞）  
老张觉得自己有点傻  
>
> 2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）  
老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。  
>
> 3 老张把响水壶放到火上，立等水开。（异步阻塞）  
老张觉得这样傻等意义不大  
>
> 4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）  
老张觉得自己聪明了。  
>  
> 所谓同步异步，只是对于水壶而言。  
普通水壶，同步；响水壶，异步。  
虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。  
同步只能让调用者去轮询自己（情况 2 中），造成老张效率的低下。  
>  
> 所谓阻塞非阻塞，仅仅对于老张而言。  
立等的老张，阻塞；看电视的老张，非阻塞。  
情况 1 和情况 3 中老张就是阻塞的，媳妇喊他都不知道。虽然 3 中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。  

### 再举个栗子

> 这里主要是针对其他网友的疑问做的补充和修改，考虑到需要在编程概念上更严谨一点。  
>  
> 阻塞非阻塞表示下面 买书过程中 可能出现的状态，是从 我 这个单进程角度来看待这个买书这个问题。  
同步异步表示一种协作方式，是从全局更高的角度 “进程之间 合作的方式” 来看待买书这个业务。两个进程之间如果商量采用异步方式处理买书这一业务，就不存在阻塞这种状态。  
>    
> A.概念  
>
> 阻塞非阻塞： 请求不能立即得到应答，需要等待，那就是阻塞；否则可以理解为非阻塞。  
>  
> 同步异步： 某业务需要甲乙甚至多方合作的时候，  
>  
> 总是按照“甲方请求一次，乙方应答一次”这样的有序序列处理业务，只有当“一次请求一次应答”的过程结束才可以发生下一次的“一次请求一次应答”，那么就说他们采用的是同步。（同步 IO 中，对同一个描述符的操作必须是有序的）  
如果甲方只要有需要，就会发送请求，不管上次请求有没有得到乙方应答。而乙方只要甲方有请求就会接受，不是等这次请求处理完毕再接受甲方新请求。这样请求应答分开的序列，就可以认为是异步。异步情况下，请求和应答不需要一致进行，可能甲方后请求的业务，却先得到乙方的应答。同步是线性的，而异步可以认为是并发的。（异步 IO 中，异步 IO 可以允许多方同时对同一个描述符发送 IO 请求，或者一次发多个请求，当然有机制保证如何区分这些请求，）  
举个例子：  
>  
> 我去买一本书，立即买到了，或者没有就走了，这就是非阻塞；（编程中设置 IO 成非阻塞，返回后再去检查描述符，或者等待通知，然后再去读取。相当于老板告诉我可以先忙点别的，过一会再来问问，或者老板通知我。但期间这个窗口(文件描述符)别人是用不了的）("立即买到了"在 IO 中也需要等待，不能算非阻塞 IO)  
如果恰好书店没有，我就等一直等到书店有了这本书买到了才走，这就是阻塞；而排在我后面的人呢只有我买到了书后才能再买书了。  
如果书店恰好没有，我就告诉书店老板，书来了告诉我一声让我来取或者直接送到我家，然后我就走了，去做别的事了，这就是异步。这时候如果很多人来买书，都是老板登记一下完事。 (从 IO 角度来说，“告诉我来取”，这个近似于信号驱动 IO ，不能算异步 IO 。必须书送到我家才算是异步，如果不送到我家，我想看这本书之前，终究还是需要我跑一趟)  
前面两种情况，非阻塞和阻塞都可以称为同步。  
反映在编程方面就是 用户进程 调用 系统调用。(用户进程对应我，内核 对应 书店老板，书对应数据资源 data ， 买书就是一个系统调用了，其中内核拷贝数据到进程这个过程近似于老板送书到我手中）。  
>  
> B. 在同步异步 IO 概念中，  
>  
> 同步异步的不同在于，针对同一个描述符上的 IO 操作，从 IO 操作发起 到 得到 IO 结果 这个过程而言，总是按照“发起请求，得到结果”这个有序序列进行的，这样便有了最小的等待这种情况：读取时，确知 IO 有数据，但需要等待内核拷贝数据到进程空间。这个最小情况的等待，同步 IO 都有。  
>  
> unix 网络编程中将 IO 模型分为 5 类：阻塞 IO ，非阻塞 IO ， IO 复用，信号驱动，异步 IO 。  
>  
> 阻塞 IO 就是那种 recv, read ，一直等，等到有了数据才返回；  
非阻塞 IO 就是立即返回，设置描述符为非阻塞，但是要进程自己一直检查是否可读；  
IO 复用其实也是阻塞的，不过可以用来等很多描述符，比起阻塞有了进步，可以算有点异步了，但需要阻塞着检查是否可读。对同一个描述符的 IO 操作也是有序的。  
信号驱动采用信号机制等待，有了更多的进步，不用监视描述符了，而且不用阻塞着等待数据到来，被动等待信号通知，由信号处理程序处理。但对同一个描述符的 IO 操作还是有序的。  
异步 IO ，发送 IO 请求后，不用等了，也不再需要发送 IO 请求获取结果了。等到通知后，其实是系统帮你把数据读取好了的，你等到的通知也不再是要求你去读写 IO 了，而是告诉你 IO 请求过程已经结束了。你要做的就是可以处理数据了。且同一个描述符上可能同时存在很多请求。(对应上面那个买书例子中，就是送书到我家，我直接看书就行了，不需要再去跑一趟了)。  
其中 IO 服用和信号驱动，在处理业务逻辑上可以说有异步，但在 IO 操作层面上来说还是同步的。  
>  
> posix.1 严格定义的异步 IO 是要求没有任何一点阻塞，而上述的前面四个（阻塞 IO ，非阻塞 IO ， IO 复用，信号驱动）都不同程度阻塞了，而且都有一个共同的阻塞： 内核拷贝数据到进程空间的这段时间需要等待。 (所以上面的举例中： 必须要书送到我家，否则都不算异步，纠结。。。)  
  
### 简单点说
      
> 阻塞就是干不完不准回来，  
非阻塞就是你先干，我现看看有其他事没有，完了告诉我一声  
>  
> 我们拿最常用的 send 和 recv 两个函数来说吧...  
比如你调用 send 函数发送一定的 Byte,在系统内部 send 做的工作其实只是把数据传输(Copy)到 TCP/IP 协议栈的输出缓冲区,它执行成功并不代表数据已经成功的发送出去了,如果 TCP/IP 协议栈没有足够的可用缓冲区来保存你 Copy 过来的数据的话...这时候就体现出阻塞和非阻塞的不同之处了:对于阻塞模式的 socket send 函数将不返回直到系统缓冲区有足够的空间把你要发送的数据 Copy 过去以后才返回,而对于非阻塞的 socket 来说 send 会立即返回 WSAEWOULDDBLOCK 告诉调用者说:"发送操作被阻塞了!!!你想办法处理吧..."  
对于 recv 函数,同样道理,该函数的内部工作机制其实是在等待 TCP/IP 协议栈的接收缓冲区通知它说:嗨,你的数据来了.对于阻塞模式的 socket 来说如果 TCP/IP 协议栈的接收缓冲区没有通知一个结果给它它就一直不返回:耗费着系统资源....对于非阻塞模式的 socket 该函数会马上返回,然后告诉你: WSAEWOULDDBLOCK---"现在没有数据,回头在来看看"  
>  
> 扩展:  
>  
> 在进行网络编程时，我们常常见到同步、异步、阻塞和非阻塞四种调用方式。这些方式彼此概念并不好理解。下面是我对这些术语的理解。  
>  
> 同步  
所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。按照这个定义，其实绝大多数函数都是同步调用（例如 sin, isdigit 等）。但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。最常见的例子就是 SendMessage 。该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。当对方处理完毕以后，该函数才把消息处理函数所返回的 LRESULT 值返回给调用者。  
>  
> 异步  
异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。以 CAsycSocket 类为例（注意， CSocket 从 CAsyncSocket 派生，但是起功能已经由异步转化为同步），当一个客户端通过调用 Connect 函数发出一个连接请求后，调用者线程立刻可以向下运行。当连接真正建立起来以后， socket 底 层会发送一个消息通知该对象。这里提到执行部件和调用者通过三种途径返回结果：状态、通知和回调。可以使用哪一种依赖于执行部件的实现，除非执行部件提供 多种选择，否则不受调用者控制。如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循 环去检查某个变量的值，这其实是一种很严重的错误）。如果是使用通知的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知 没太多区别。  
>  
> 阻塞  
阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。有人也许会把阻塞调用和同步调用等同起来，实际上它们是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。例如，我们在 CSocket 中调用 Receive 函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。如果主窗口和调用函数在同一个线程中，除非你在特殊的界面操作函数中调用，其实主界面还是应该可以刷新。 socket 接收数据的另外一个函数 recv 则是一个阻塞调用的例子。当 socket 工作在阻塞模式的时候， 如果没有数据的情况下调用该函数，则当前线程就会被挂起，直到有数据为止。  
>  
> 非阻塞  
非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。  
>  
> 对象的阻塞模式和阻塞函数调用  
对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但是并不是一一对应的。阻塞对象上可以有非阻塞的调用方式，我们可以通过一定的 API 去轮询状态，在适当的时候调用阻塞函数，就可以避免阻塞。而对于非阻塞对象，调用特殊的函数也可以进入阻塞调用。函数 select 就是这样的一个例子。  
