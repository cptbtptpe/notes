## 架构  

### 什么是架构

> 用一段通俗的话说，架构就是 "最高层次的规划，是难以改变的决定"  
>
> 架构和人生一样
决定上什么样的学校、决定学什么样的专业、毕业后决定找什么样的工作、进什么样的公司、过什么样的生活
这些都是一种架构，一旦它们被决定，则会影响深厚并且难以改变。

### 作为一名架构师
    
* `架构要素一`：性能，比如搜索引擎 `Lucene` 和 `Sphinx` 的选择。
* `架构要素二`：可用性，保证业务服务的 `7 * 24` 的可用性，最大减小服务瘫痪的几率，比如 `Mongodb ReplSet`。
* `架构要素三`：伸缩性，考虑公司业务增长情况，我们应当使用集群，并且在业务的增减下很容易的实现对集群的控制，比如分布式文件系统和分布式数据库。
* `架构要素四`：扩展性，将业务和可用服务进行分离，通过服务的思想来实现业务，这样在今后的产品变更时，可以很容易的实现这些需求，比如开放平台和接口。
* `架构要素五`：安全性，保护网站不受恶意访问和攻击，比如 `CSRF` 和 `XSS` 的避免。

### Lucene 和 Sphinx

* Lucene

    * 索引文件格式独立于应用平台
    * 在传统全文检索引擎的倒排索引的基础上，实现了分块索引，能够针对新的文件建立小文件索引，提升索引速度
    * 优秀的面向对象的系统架构，使得对于 Lucene 扩展的学习难度降低
    * 设计了独立于语言和文件格式的文本分析接口，索引器通过接受 Token 流完成索引文件的创立，用户扩展新的语言和文件格式，只需要实现文本分析的接口
    * 已经默认实现了一套强大的查询引擎，用户无需自己编写代码即使系统可获得强大的查询能力， Lucene 的查询实现中默认实现了布尔操作、模糊查询、分组查询等等
    
* Sphinx
    
    * 性能非常出色，在 2-4GB 的文本上搜索，平均 0.1 秒内获得结果
    * 高扩展性（实测最高可对 100GB 的文本建立索引，单一索引可包含 1 亿条记录）
    * 支持分布式检索
    * 和数据库集成性很好
    * 做 MySQL 的全文检索得心应手

### 堆栈和队列  

* `队列` 只能在队头做删除操作, 在队尾做插入操作.而栈只能在栈顶做插入和删除操作  
* `栈` 就是一个桶，后放进去的先拿出来，它下面本来有的东西要等它出来之后才能出来  
* `堆` 是在程序运行时，而不是在程序编译时，申请某个大小的内存空间  

    > 即动态分配内存，对其访问和对一般内存的访问没有区别。
堆是指程序运行是申请的动态内存，而栈只是指一种使用堆的方法(即先进后出)
栈是先进后出的，但是于堆而言却没有这个特性，两者都是存放临时数据的地方。 对于堆，我们可以随心所欲的进行增加变量和删除变量，不要遵循什么次序，只要你喜欢。

### 常用加密算法

- [x] `AES`: 更快，兼容设备，安全级别高；
- [x] `SHA1`: 公钥后处理回传
- [x] `DES`: 本地数据，安全级别低
- [x] `RSA`: 非对称加密，有公钥和私钥
- [x] `MD5`: 防篡改

#### 非对称加密/公开密钥加密

> 公开密钥加密（ public-key cryptography ），也称为非对称加密（ asymmetric cryptography ）
>
> 一种密码学算法类型，在这种密码学方法中，需要一对密钥，一个是私人密钥，另一个则是公开密钥
这两个密钥是数学相关，用某用户密钥加密后所得的信息，只能用该用户的解密密钥才能解密
>
> 如果知道了其中一个，并不能计算出另外一个。因此如果公开了一对密钥中的一个，并不会危害到另外一个的秘密性质
称公开的密钥为公钥；不公开的密钥为私钥
    
#### RSA 密钥生成

> \$ openssl genrsa -out rsa_private_key.pem 1024  
\$ openssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM -nocrypt  
\$ openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem  
\$ openssl asn1parse -i -inform PEM < rsa_private_key.pem > hex.log  
>
> 最后一个命令生成的结果
第一段为公钥十六进制串可用于 JS 端加密
第二段为密钥十六进制串可用于 JS 端加密

#### DES

> DES 现在已经不是一种安全的加密方法，主要因为它使用的 56 位密钥过短
>
> 1999 年 1 月， distributed.NET 与电子前哨基金会合作，在 22 小时 15 分钟内即公开破解了一个 DES 密钥
也有一些分析报告提出了该算法的理论上的弱点，虽然在实际中难以应用
>
> 为了提供实用所需的安全性，可以使用 DES 的派生算法 3DES 来进行加密，虽然 3DES 也存在理论上的攻击方法
在 2001 年， DES 作为一个标准已经被高级加密标准（ AES ）所取代
>
> 另外， DES 已经不再作为国家标准科技协会（前国家标准局）的一个标准。

#### AES

> 高级加密标准（ Advanced Encryption Standard ）
>
> 在密码学中又称 Rijndael 加密法，是美国联邦政府采用的一种区块加密标准
这个标准用来替代原先的 DES ，已经被多方分析且广为全世界所使用
经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（ NIST ）于 2001 年 11 月 26 日发布于 FIPS PUB 197
并在 2002 年 5 月 26 日成为有效的标准。 2006 年，高级加密标准已然成为对称密钥加密中最流行的算法之一

#### MD5 && SHA1

> MD5 和 SHA1 是 2 种加密算法，用于计算出一段不可逆向计算的数值，以此来验证该文件是否被修改的
>
> 在 1993 年，安全散列算法（ SHA ）由美国国家标准和技术协会(NIST)提出，并作为联邦信息处理标准（ FIPS PUB 180 ）公布
1995 年又发布了一个修订版 FIPS PUB 180-1 ，通常称之为 SHA-1
SHA-1 是基于 MD4 算法的，并且它的设计在很大程度上是模仿 MD4 的
现在已成为公认的最安全的散列算法之一，并被广泛使用。
>
> SHA-1 是一种数据加密算法
该算法的思想是接收一段明文，然后以一种不可逆的方式将它转换成一段（通常更小）密文
也可以简单的理解为取一串输入码（称为预映射或信息）
并把它们转化为长度较短、位数固定的输出序列即散列值（也称为信息摘要或信息认证代码）的过程
>
> 单向散列函数的安全性在于其产生散列值的操作过程具有较强的单向性
如果在输入序列中嵌入密码，那么任何人在不知道密码的情况下都不能产生正确的散列值，从而保证了其安全性
SHA 将输入流按照每块 512 位（ 64 个字节）进行分块，并产生 20 个字节的被称为信息认证代码或信息摘要的输出
>
> 该算法输入报文的最大长度不超过 264 位，产生的输出是一个 160 位的报文摘要
输入是按 512 位的分组进行处理的。 SHA-1 是不可逆的、防冲突，并具有良好的雪崩效应
>
> 通过散列算法可实现数字签名实现
数字签名的原理是将要传送的明文通过一种函数运算（ Hash ）转换成报文摘要（不同的明文对应不同的报文摘要）
报文摘要加密后与明文一起传送给接受方，接受方将接受的明文产生新的报文摘要与发送方的发来报文摘要解密比较
比较结果一致表示明文未被改动，如果不一致表示明文已被篡改

#### 总结

* aes/des 加密速度快，适合大量数据
* des 容易破解，一般用 3des ，后来又出现了更快更安全的 aes
* rsa 是公钥加密，速度慢，只能处理少量数据，优点是公钥即使在不安全的网络上公开，也能保证安全
* 常见情况是双方用 rsa 协商出一个密钥后通过 aes/3des 给数据加密

### 接口相关名称概念

#### http 接口

> 基于 HTTP 协议的开发接口.这个并不能排除没有使用其他的协议

#### api 接口

> API （ Application Programming Interface ）
应用程序编程接口，应用也包括网络应用程序，就像 api 文档基本上就是使用说明书
API 接口可以简单理解成 "应用程序使用接口"

#### RPC 接口

> Remote Procedure Calls 
远程过程调用 (RPC) 是一种协议，程序可使用这种协议向网络中的另一台计算机上的程序请求服务
>
> 由于使用 RPC 的程序不必了解支持通信的网络协议的情况，因此 RPC 提高了程序的互操作性
在 RPC 中，发出请求的程序是客户程序，而提供服务的程序是服务器
RPC （远程过程调用）是一项广泛用于支持分布式应用程序（不同组件分布在不同计算机上的应用程序）的技术
RPC 的主要目的是为组件提供一种相互通信的方式，使这些组件之间能够相互发出请求并传递这些请求的结果
没有语言限制

#### RMI

> RMI （ Remote Method Invocation ，远程方法调用）
RMI 是针对于 java 语言的， RMI 允许您使用 Java 编写分布式对象

#### SOAP

> 简单对象访问协议是交换数据的一种协议规范，是一种轻量的、简单的、基于 XML （标准通用标记语言下的一个子集）的协议，它被设计成在 WEB 上交换结构化的和固化的信息。
>
> SOAP 、 WSDL(WebServicesDescriptionLanguage)、 UDDI(UniversalDescriptionDiscovery andIntegration)之一， soap 用来描述传递信息的格式， WSDL 用来描述如何访问具体的接口， uddi 用来管理，分发，查询 webService 。具体实现可以搜索 Web Services 简单实例 ; SOAP 可以和现存的许多因特网协议和格式结合使用，包括超文本传输协议（ HTTP ），简单邮件传输协议（ SMTP ），多用途网际邮件扩充协议（ MIME ）。它还支持从消息系统到远程过程调用（ RPC ）等大量的应用程序。 SOAP 使用基于 XML 的数据结构和超文本传输协议(HTTP)的组合定义了一个标准的方法来使用 Internet 上各种不同操作环境中的分布式对象。

#### Webservice 接口

> Webservice 是系统对外的接口
比如你要从别的网站或服务器上获取资源或信息，别人肯定不会把数据库共享给你
他只能给你提供一个他们写好的方法来获取数据，你引用他提供的接口就能使用他写好的方法
从而达到数据共享的目的

#### RESTful

> 简称 REST, 是描述了一个架构样式的网络系统
其核心是面向资源， REST 专门针对网络应用设计和开发方式，以降低开发的复杂性，提高系统的可伸缩性
>
> REST 提出设计概念和准则为：
>
> > \* 网络上的所有事物都可以被抽象为资源(resource)  
> > \* 每一个资源都有唯一的资源标识(resource identifier)，对资源的操作不会改变这些标识  
> > \* 所有的操作都是无状态的  
>
> 面向服务的架构（ Service-Oriented Architecture ）是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种各样的系统中的服务可以以一种统一和通用的方式进行交互。
>
> 面向服务架构，它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用。服务层是 SOA 的基础，可以直接被应用调用，从而有效控制系统中与软件代理交互的人为依赖性。
SOA 是一种粗粒度、松耦合服务架构，服务之间通过简单、精确定义接口进行通讯，不涉及底层编程接口和通讯模型。 SOA 可以看作是 B/S 模型、 XML （标准通用标记语言的子集）/Web Service 技术之后的自然延伸。
SOA 将能够帮助软件工程师们站在一个新的高度理解企业级架构中的各种组件的开发、部署形式，它将帮助企业系统架构者以更迅速、更可靠、更具重用性架构整个业务系统。较之以往，以 SOA 架构的系统能够更加从容地面对业务的急剧变化。

#### RESTful 设计要素

* 资源路径（ URI ）
* `HTTP` 方法
* 过滤信息（参数）
* 状态码
* 错误处理
* 返回结果

### 运维名词

#### QPS

> Queries Per Second 意思是每秒查询率
是一台服务器每秒能够相应的查询次数
是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准
>
> 并发数：系统同时处理的 request
响应时间：一般取平均响应时间
>
> 理解了上面三个要素的意义之后
就能推算出它们之间的关系：
QPS = 并发数 / 平均响应时间
或者
并发数 = QPS * 平均响应时间
>
> 一个典型的上班签到系统
早上 8 点上班
7 点半到 8 点的 30 分钟的时间里用户会登录签到系统进行签到
公司员工为 1000 人
平均每个员上登录签到系统的时长为 5 分钟
可以用下面的方法计算：
>
> QPS = 1000 / (30 * 60) 事务 / 秒
平均响应时间为 = 5 * 60  秒
并发数 = QPS * 平均响应时间 = 1000 / (30 * 60) * (5 * 60) = 166.7

#### TPS

> TransactionsPerSecond 意思每秒事务数
它是软件测试结果的测量单位
一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程
>
> 客户机在发送请求时开始计时，收到服务器响应后结束计时
以此来计算使用的时间和完成的事务个数，最终利用这些信息来估计得分
客户机使用加权协函数平均方法来计算客户机的得分
测试软件就是利用客户机的这些信息使用加权协函数平均方法
来计算服务器端的整体 TPS 得分

#### IOPS

> Input/Output Operations Per Second 即每秒进行读写（ I/O ）操作的次数
多用于数据库等场合，衡量随机访问的性能
存储端的 IOPS 性能和主机端的 IO 是不同的
IOPS 是指存储每秒可接受多少次主机发出的访问
主机的一次 IO 需要多次访问存储才可以完成

#### 吞吐量

> 吞吐量主要取决于阵列的构架
光纤通道的大小(阵列一般都是光纤阵列，至于 SCSI 这样的 SSA 阵列，我们不讨论)
以及硬盘的个数
>
> 阵列的构架与每个阵列不同而不同
他们也都存在内部带宽(类似于 pc 的系统总线)
不过一般情况下，内部带宽都设计的很充足，不是瓶颈的所在
>
> 光纤通道的影响还是比较大的，如数据仓库环境中，对数据的流量要求很大
而一块 2GB 的光纤卡
所能支撑的最大流量应当是 2GB / 10(小 B) = 200MB/s(大 B)的实际流量
当 5 块光纤卡才能达到 1GB/s 的实际流量
所以数据仓库环境可以考虑换 4GB 的光纤卡
>
> IOPS 和吞吐量瓶颈都解决后应该要考虑硬盘瓶颈了
    
#### PV

> 访问量，即 Page View
即页面浏览量或点击量
用户每次刷新即被计算一次
>
> PV 反映的是浏览某网站的页面数
所以每刷新一次也算一次
就是说 PV 与来访者的数量成正比
但 PV 并不是页面的来访者数量，而是网站被访问的页面数量

#### UV

> 独立访客，即 Unique 　 Visitor
访问您网站的一台电脑客户端为一个访客
00:00-24:00 内相同的客户端只被计算一次
>
> 可以理解成访问某网站的电脑的数量
网站判断来访电脑的身份是通过来访电脑的 cookies 实现的
如果更换了 IP 后但不清除 cookies
再访问相同网站，该网站的统计中 UV 数是不变的

#### IP

> 独立 IP ，即 Internet 　 Protocol
指独立 IP 数
00:00-24:00 内相同 IP 地址只被计算一次
>
> 某 IP 地址的计算机访问网站的次数
这种统计方式很容易实现，具有真实性
所以是衡量网站流量的重要指标

### 同步、异步和阻塞、非阻塞  
  
> "阻塞" 与 "非阻塞" 和 "同步" 与 "异步" 不能简单的从字面理解，提供一个从分布式系统角度的回答。  
    
#### 同步与异步  

> 同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)  
所谓同步，就是在发出一个"调用"时，在没有得到结果之前，该"调用"就不返回。但是一旦调用返回，就得到返回值了。  
换句话说，就是由"调用者"主动等待这个"调用"的结果。  
>  
> 而异步则是相反，"调用"在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在"调用"发出后，"被调用者"通过状态、通知来通知调用者，或通过回调函数处理这个调用。  
>  
> 典型的异步编程模型比如 Node.js  
>  
> 举个通俗的例子：  
你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，"我查一下"，然后开始查啊查，等查好了（可能是 5 秒，也可能是一天）告诉你结果（返回结果）。  
而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过"回电"这种方式来回调。  
      
#### 阻塞与非阻塞  
    
> 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.  
阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。  
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。  
>  
> 还是上面的例子，  
你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己"挂起"，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟 check 一下老板有没有返回结果。  
在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。  

#### 举个栗子

> 老张爱喝茶，废话不说，煮开水。  
>
> 出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。  
>
> 1 老张把水壶放到火上，立等水开。（同步阻塞）  
老张觉得自己有点傻  
>
> 2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）  
老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。  
>
> 3 老张把响水壶放到火上，立等水开。（异步阻塞）  
老张觉得这样傻等意义不大  
>
> 4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）  
老张觉得自己聪明了。  
>  
> 所谓同步异步，只是对于水壶而言。  
普通水壶，同步；响水壶，异步。  
虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。  
同步只能让调用者去轮询自己（情况 2 中），造成老张效率的低下。  
>  
> 所谓阻塞非阻塞，仅仅对于老张而言。  
立等的老张，阻塞；看电视的老张，非阻塞。  
情况 1 和情况 3 中老张就是阻塞的，媳妇喊他都不知道。虽然 3 中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。  

#### 再举个栗子

> 这里主要是针对其他网友的疑问做的补充和修改，考虑到需要在编程概念上更严谨一点。  
>  
> 阻塞非阻塞表示下面 买书过程中 可能出现的状态，是从 我 这个单进程角度来看待这个买书这个问题。  
同步异步表示一种协作方式，是从全局更高的角度 “进程之间 合作的方式” 来看待买书这个业务。两个进程之间如果商量采用异步方式处理买书这一业务，就不存在阻塞这种状态。  
>    
> A.概念  
>
> 阻塞非阻塞： 请求不能立即得到应答，需要等待，那就是阻塞；否则可以理解为非阻塞。  
>  
> 同步异步： 某业务需要甲乙甚至多方合作的时候，  
>  
> 总是按照“甲方请求一次，乙方应答一次”这样的有序序列处理业务，只有当“一次请求一次应答”的过程结束才可以发生下一次的“一次请求一次应答”，那么就说他们采用的是同步。（同步 IO 中，对同一个描述符的操作必须是有序的）  
如果甲方只要有需要，就会发送请求，不管上次请求有没有得到乙方应答。而乙方只要甲方有请求就会接受，不是等这次请求处理完毕再接受甲方新请求。这样请求应答分开的序列，就可以认为是异步。异步情况下，请求和应答不需要一致进行，可能甲方后请求的业务，却先得到乙方的应答。同步是线性的，而异步可以认为是并发的。（异步 IO 中，异步 IO 可以允许多方同时对同一个描述符发送 IO 请求，或者一次发多个请求，当然有机制保证如何区分这些请求，）  
举个例子：  
>  
> 我去买一本书，立即买到了，或者没有就走了，这就是非阻塞；（编程中设置 IO 成非阻塞，返回后再去检查描述符，或者等待通知，然后再去读取。相当于老板告诉我可以先忙点别的，过一会再来问问，或者老板通知我。但期间这个窗口(文件描述符)别人是用不了的）("立即买到了"在 IO 中也需要等待，不能算非阻塞 IO)  
如果恰好书店没有，我就等一直等到书店有了这本书买到了才走，这就是阻塞；而排在我后面的人呢只有我买到了书后才能再买书了。  
如果书店恰好没有，我就告诉书店老板，书来了告诉我一声让我来取或者直接送到我家，然后我就走了，去做别的事了，这就是异步。这时候如果很多人来买书，都是老板登记一下完事。 (从 IO 角度来说，“告诉我来取”，这个近似于信号驱动 IO ，不能算异步 IO 。必须书送到我家才算是异步，如果不送到我家，我想看这本书之前，终究还是需要我跑一趟)  
前面两种情况，非阻塞和阻塞都可以称为同步。  
反映在编程方面就是 用户进程 调用 系统调用。(用户进程对应我，内核 对应 书店老板，书对应数据资源 data ， 买书就是一个系统调用了，其中内核拷贝数据到进程这个过程近似于老板送书到我手中）。  
>  
> B. 在同步异步 IO 概念中，  
>  
> 同步异步的不同在于，针对同一个描述符上的 IO 操作，从 IO 操作发起 到 得到 IO 结果 这个过程而言，总是按照“发起请求，得到结果”这个有序序列进行的，这样便有了最小的等待这种情况：读取时，确知 IO 有数据，但需要等待内核拷贝数据到进程空间。这个最小情况的等待，同步 IO 都有。  
>  
> unix 网络编程中将 IO 模型分为 5 类：阻塞 IO ，非阻塞 IO ， IO 复用，信号驱动，异步 IO 。  
>  
> 阻塞 IO 就是那种 recv, read ，一直等，等到有了数据才返回；  
非阻塞 IO 就是立即返回，设置描述符为非阻塞，但是要进程自己一直检查是否可读；  
IO 复用其实也是阻塞的，不过可以用来等很多描述符，比起阻塞有了进步，可以算有点异步了，但需要阻塞着检查是否可读。对同一个描述符的 IO 操作也是有序的。  
信号驱动采用信号机制等待，有了更多的进步，不用监视描述符了，而且不用阻塞着等待数据到来，被动等待信号通知，由信号处理程序处理。但对同一个描述符的 IO 操作还是有序的。  
异步 IO ，发送 IO 请求后，不用等了，也不再需要发送 IO 请求获取结果了。等到通知后，其实是系统帮你把数据读取好了的，你等到的通知也不再是要求你去读写 IO 了，而是告诉你 IO 请求过程已经结束了。你要做的就是可以处理数据了。且同一个描述符上可能同时存在很多请求。(对应上面那个买书例子中，就是送书到我家，我直接看书就行了，不需要再去跑一趟了)。  
其中 IO 服用和信号驱动，在处理业务逻辑上可以说有异步，但在 IO 操作层面上来说还是同步的。  
>  
> posix.1 严格定义的异步 IO 是要求没有任何一点阻塞，而上述的前面四个（阻塞 IO ，非阻塞 IO ， IO 复用，信号驱动）都不同程度阻塞了，而且都有一个共同的阻塞： 内核拷贝数据到进程空间的这段时间需要等待。 (所以上面的举例中： 必须要书送到我家，否则都不算异步，纠结。。。)  
  
#### 简单点说
      
> 阻塞就是干不完不准回来，  
非阻塞就是你先干，我现看看有其他事没有，完了告诉我一声  
>  
> 我们拿最常用的 send 和 recv 两个函数来说吧...  
比如你调用 send 函数发送一定的 Byte, 在系统内部 send 做的工作其实只是把数据传输(Copy)到 TCP/IP 协议栈的输出缓冲区, 它执行成功并不代表数据已经成功的发送出去了, 如果 TCP/IP 协议栈没有足够的可用缓冲区来保存你 Copy 过来的数据的话...这时候就体现出阻塞和非阻塞的不同之处了:对于阻塞模式的 socket send 函数将不返回直到系统缓冲区有足够的空间把你要发送的数据 Copy 过去以后才返回, 而对于非阻塞的 socket 来说 send 会立即返回 WSAEWOULDDBLOCK 告诉调用者说:"发送操作被阻塞了!!!你想办法处理吧..."  
对于 recv 函数, 同样道理, 该函数的内部工作机制其实是在等待 TCP/IP 协议栈的接收缓冲区通知它说:嗨, 你的数据来了.对于阻塞模式的 socket 来说如果 TCP/IP 协议栈的接收缓冲区没有通知一个结果给它它就一直不返回:耗费着系统资源....对于非阻塞模式的 socket 该函数会马上返回, 然后告诉你: WSAEWOULDDBLOCK---"现在没有数据, 回头在来看看"  
>  
> 扩展:  
>  
> 在进行网络编程时，我们常常见到同步、异步、阻塞和非阻塞四种调用方式。这些方式彼此概念并不好理解。下面是我对这些术语的理解。  
>  
> 同步  
所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。按照这个定义，其实绝大多数函数都是同步调用（例如 sin, isdigit 等）。但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。最常见的例子就是 SendMessage 。该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。当对方处理完毕以后，该函数才把消息处理函数所返回的 LRESULT 值返回给调用者。  
>  
> 异步  
异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。以 CAsycSocket 类为例（注意， CSocket 从 CAsyncSocket 派生，但是起功能已经由异步转化为同步），当一个客户端通过调用 Connect 函数发出一个连接请求后，调用者线程立刻可以向下运行。当连接真正建立起来以后， socket 底 层会发送一个消息通知该对象。这里提到执行部件和调用者通过三种途径返回结果：状态、通知和回调。可以使用哪一种依赖于执行部件的实现，除非执行部件提供 多种选择，否则不受调用者控制。如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循 环去检查某个变量的值，这其实是一种很严重的错误）。如果是使用通知的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知 没太多区别。  
>  
> 阻塞  
阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。有人也许会把阻塞调用和同步调用等同起来，实际上它们是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。例如，我们在 CSocket 中调用 Receive 函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。如果主窗口和调用函数在同一个线程中，除非你在特殊的界面操作函数中调用，其实主界面还是应该可以刷新。 socket 接收数据的另外一个函数 recv 则是一个阻塞调用的例子。当 socket 工作在阻塞模式的时候， 如果没有数据的情况下调用该函数，则当前线程就会被挂起，直到有数据为止。  
>  
> 非阻塞  
非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。  
>  
> 对象的阻塞模式和阻塞函数调用  
对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但是并不是一一对应的。阻塞对象上可以有非阻塞的调用方式，我们可以通过一定的 API 去轮询状态，在适当的时候调用阻塞函数，就可以避免阻塞。而对于非阻塞对象，调用特殊的函数也可以进入阻塞调用。函数 select 就是这样的一个例子。  

### 依赖注入和服务定位器  
  
#### 依赖倒置原则（ Dependence Inversion Principle, DIP ）  

> `DIP` 是一种软件设计的指导思想。传统软件设计中，上层代码依赖于下层代码，当下层出现变动时， 上层代码也要相应变化，维护成本较高。而 DIP 的核心思想是上层定义接口，下层实现这个接口， 从而使得下层依赖于上层，降低耦合度，提高整个系统的弹性。这是一种经实践证明的有效策略。  
  
#### 控制反转（ Inversion of Control, IoC ）  

> `IoC` 就是 `DIP` 的一种具体思路，`DIP` 只是一种理念、思想，而 `IoC` 是一种实现 `DIP` 的方法。 `IoC` 的核心是将类（上层）所依赖的单元（下层）的实例化过程交由第三方来实现。 一个简单的特征，就是类中不对所依赖的单元有诸如 `$component = new yii\component\SomeClass （）` 的实例化语句。  
  
#### 依赖注入（ Dependence Injection, DI ）  

> `DI` 是 `IoC` 的一种设计模式，是一种套路，按照 `DI` 的套路，就可以实现 `IoC`，就能符合 `DIP` 原则。 `DI` 的核心是把类所依赖的单元的实例化过程，放到类的外面去实现。  
  
#### 控制反转容器（ IoC Container ）  

> 当项目比较大时，依赖关系可能会很复杂。 而 `IoC` `Container `提供了动态地创建、注入依赖单元，映射依赖关系等功能，减少了许多代码量。 `Yii` 设计了一个 `yii\di\Container`  来实现了 `DI Container`。  
  
#### 服务定位器（ Service Locator ）  

> `Service Locator` 是 `IoC` 的另一种实现方式， 其核心是把所有可能用到的依赖单元交由 `Service Locator` 进行实例化和创建、配置， 把类对依赖单元的依赖，转换成类对 `Service Locator` 的依赖。 `DI` 与 `Service Locator` 并不冲突，两者可以结合使用。 目前，`Yii2.0` 把这 `DI` 和 `Service Locator` 这两个东西结合起来使用，或者说通过 `DI` 容器，实现了 `Service Locator`。  
是不是云里雾里的？没错，所谓“高大上”的玩意往往就是这样，看着很炫，很唬人。 卖护肤品的难道会跟你说其实皮肤表层是角质层，不具吸收功能么？这玩意又不考试，大致意会下就可以了。 万一哪天要在妹子面前要装一把范儿的时候，张口也能来这么几个“高大上”就行了。 但具体的内涵，我们还是要要通过下面的学习来加深理解，毕竟要把“高大上”的东西用好，发挥出作用来。  
  
#### 依赖注入的实现方法
  
* 构造注入 - `setter`
* 属性注入 - `__construct`
* 接口注入 - `interface`

### FAST-CGI 和 PHP-FPM
  
> 首先， cgi 是为了保证 web server 传递过来的数据是标准格式的，方便 cgi 程序的编写者。  
>  
>  web server （比如说 nginx ）只是内容的分发者。比如，如果请求 `/index.html`，那么 web server 会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。好了，如果现在请求的是 `/index.php`，根据配置文件， nginx 知道这个不是静态文件，需要去找 php 解析器来处理，那么他会把这个请求简单处理后交给 php 解析器。 nginx 需要传 url 、查询字符串、 post 数据、 http header 给 php 解析器， cgi 就是规定要传哪些数据、以什么样的格式传递给后方处理这个请求的协议。

> 当 web server 收到 `/index.php` 这个请求后，会启动对应的 cgi 程序，这里就是 php 的解析器。接下来 php 解析器会解析 php.ini 文件，初始化执行环境，然后处理请求，再以规定 cgi 规定的格式返回处理后的结果，退出进程。 web server 再把结果返回给浏览器。  
好了， cgi 是个协议程序， fast-cgi 则是用来提高 cgi 程序性能的工具。  
>  
> cgi 的性能问题出在 php 解析器会重复解析 php.ini 文件和初始化执行环境，首先， fast-cgi 会先启一个 master ，解析配置文件，初始化执行环境，然后再启动多个 worker 。当请求过来时， master 会传递给一个 worker ，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率自然是高。而且当 worker 不够用时， master 可以根据配置预先启动几个 worker 等着；当然空闲 worker 太多时，也会停掉一些，这样就提高了性能，也节约了资源。这就是 fast-cgi 的对进程的管理。  
  
> php 的解释器是 php-cgi 。 php-cgi 只是个 cgi 程序，他自己本身只能解析请求，返回结果，不会进程管理，所以就出现了一些能够调度 php-cgi 进程的程序 php-fpm 。

### Web 安全  
  
#### 网络传输安全  
  
* TCP 协议数据包  
    * 相关知识  
        
        | OSI 层 | 协议 | 作用 | 设备 |
        | --- | --- | --- | --- |
        | 应用层 | HTTP | | 网关（程序）  
        | 安全层(HTTPs) | SSL/TSL | 数据封装、压缩、加密  | | 
        | 传输层 | TCP | 数据块、数据分组 | |
        | 网络层 | IP | | 路由器 |
        | 数据链路层 | | 网络特有的链路接口 | 网桥（ Bridge ）、交换机（ Switch ）| 
        | 物理层 | | 网络硬件 | 集线器（ Hub ）、中继器（ Repeater ） |
  
        HTTP    超文本传输协议  
        TCP     传输控制协议  
    * 引起原因  
        
        数据在传输过程中被修改或泄露  
    
    * 危害  
        
        数据丢失、数据被修改  
    
    * 解决方案  
        
        数据加密、数据签名  
  
* 压力测试  
    * 相关知识  
        
        `apache` 压力测试工具 ab  
        
        ```  
        # `ulimit` 可修改最多连接数
        ab -n 1000 -c 100 HTTP://www.baidu.com/  
        ```  

    * 引起原因  
        
        单 `ip` 恶意访问  
    
    * 危害  
        
        主机直接卡死  
    
    * 解决方案  
        
        通过 `web` 服务器对单 `ip` 并发进行限制  
  
* 洪水攻击 - `SYNflood`  
    * 相关知识  
        
        `TCP` 协议漏洞之三部握手: `SYN` -> `ACK` + `SYN` -> `ACK`  
    
    * 引起原因  
        
        `SYN` 类型的请求只有 40~60 字节  
        当开放了一个 `TCP` 端口后，该端口就处于 `Listening` 状态，不停地监视发到该端口的 `SYN` 报文  
        一旦接收到 `client` 发来的 `SYN` 报文，就需要为该请求分配一个 `TCB`（ Transmission Control Block ）  
        通常一个 `TCB` 至少需要 280 个字节，在某些操作系统中 `TCB` 甚至需要 1300 个字节，并返回一个 `SYN` `ACK` 命令，立即转为 `SYN-RECEIVED` 即半开连接状态  
    
    * 危害  
        
        属于 `DOS` 攻击的一种，通过发送大量的半连接请求，耗费主机的 `CPU` 和内存资源，还可以影响路由器、防火墙  
    
    * 解决方案  
        
        网关超时设置、`TCP`\`ip` 协议栈的 `SynAttACKProtect` 保护机制  
  
#### 逻辑安全  
  
* `XSS` (跨站脚本攻击 - Cross Site Scripting)  
    * 定义  
        
        通过插入恶意脚本，实现对用户游览器的控制  
    
    * 解决方案  
        
        通过 `strip_tags`、`htmlentities`、`htmlspecialchars`  
* `CSRF` (跨站请求伪造 - Cross Site Request Forgery)  
    * 相关知识  
        
        `HTTP` 协议本身是一个无状态的协议，在请求时判断不了客户端的用户信息  
        于是在 `HTTP` 请求报文首部会携带 `Cookie` 头部  
        `Cookie` 中含有一个 `PHPSESSID` 的值，就是用来存储 `session` 的用户唯一标记，用户获取 `session` 的时候 `php` 会到 `Cookie` 中找到这个 `PHPSESSID` 的值  
        然后到 `session` 文件存储目录中找 `sess_{PHPSESSID}` 的文件，获取里面的内容并反序列化  
  
        | Method | 含义 |  
        | --- | --- |  
        | GET | 请求服务器发送某个资源 |  
        | HEAD | 与 GET 方法的行为很类似，但服务器在响应中只返回首部。不会反回实体的主体部分 |  
        | POST | 创建一个不存在的资源，通常用于 html 的 form 表单 |  
        | PUT | 创建一个已存在的资源，即完全替换 |  
        | *PATCH | 用来对已知资源进行局部更新 |  
        | TRACE | 允许客户端在最终将请求发送给服务器时，看看他变成了什么样子 |  
        | OPTIONS | 请求 WEB 服务器告知其支持的各种功能 |  
        | DELETE | 请服务器删除请求 URL 所指定的资源 |  
  
    * 定义  
        
        攻击者盗用了你的身份，以你的名义发送恶意请求  
    
    * 解决方案  
        
        在客户端请求服务端时加入一个 `token`，因为这个 `token` 在理论上是不会被第三方网站获取的(含 `XSS` 隐患除外)  
        通过对比提交的 `token` 和服务器的 `token` 来判断请求是非来自第三方网站  
  
* `sql` 注入  
    * 相关知识  
        
        `UNION` 把两次或多次的查询结果合并(查询的 `field` 数目必须一致)  

        ```
        SELECT id, uri, remark 
        FROM integle_notes.menu 
        LIMIT 3 
        UNION 
        SELECT id, email, password 
        FROM integle_notes.user  
        ```   
        
    * 定义  
        
        `SQL` 注入攻击中以 `SQL` 语句作为用户输入，从而达到查询/修改/删除数据的目的  
    
    * 解决方案  
        
        将 `php.ini` 文件中的 `safe_mode` 设置为 `on` 开启安全模式  
        将 `php.ini` 文件中的 `magic_quotes_gpc` 设置为 `on` 对用户提交的数据自动添加斜线(转义)  
        使用 `mysql_real_escape_string`、`mysql_escape_string`、`addslashes`、过滤 `sql` 关键字  
  
#### 代码安全(`php`)  
  
* `eval`/`assert`/`system`  
* 文件上传漏洞  
  
### 攻防知识点 
  
#### Cross Site Scripting - 跨站脚本攻击 - XSS  
  
* XSS 满足条件  
    * 在 URL 中输入的值在页面有有输出  
    * 输出最好是在 script 标签内  
  
* 通过 document.cookie 获取当前用户的 cookie 信息，该 cookie 必须是非 httponly 状态才能用 javascript 代码获取  
* HTML URL 编码  
    * `"` => `%22`  
    * `;` => `%3B`  
    * 可以使用 escape('x') 函数获取字符的 URL 编码  
* HTML 实体编码  
    * `<` => `&lt;`  
    * `>` => `&gt;`  
    * `"` => `&quot;`  
* 扩展攻击之蠕虫攻击  
    * 通过攻击页面，然后在页面中再次嵌入该攻击 URL 进行扇形扩展式攻击  
  
#### Cross Site Request Forgery - 跨站请求伪造 - CSRF  
  
* 通过点击隐藏连接执行用户本意不想执行的 URL ，该 URL 一般含某些动作  
  
#### SQL 注入  
  
* 关键字  
    * 注释： username=xxx --  
    * 条件： username=xxx OR 1=1  
    * 条件： username=xxx || 1=1  
    * 截断： username=xxx'; DROP TABLE \`users\`;  
    * 合并： username=xxx UNION SELECT * FROM \`users\`;  
  
#### 上传文件漏洞 - 适用于 php web 服务器  
  
* 需要满足文件上传前和上传后的文件名称一致的条件  
* 预先准备一个 hello.phpabc.jpg  
* 表面是 jpg 图片文件，其内容为 php 代码  
* 在上传的时候可使用抓包工具 fiddler 软件修改 header 信息，将文件名修改为 * hello.php;abc.jpg ，甚至可以修改文件的 mime 类型  
* 该文件可以通过 php 服务器的正常验证，当在 move_upload_files 时该文件会自动保存为 hello.php  
* 然后就可以通过 url 访问该 php 文件执行其中的 php 代码了  
  
#### 相关知识书籍推荐  
* 《白帽子讲 web 安全》  
* 《 HTTP 权威指南》  

