    
## MySQL锁    
    
**行级锁 － InnoDB**    
`特点`：开销大，加锁慢，容易出现死锁；锁粒度最小，发生冲突概率最低，并发度最高。    
注意事项：行锁说通过给索引加锁来实现的，只有通过索引条件检索的数据才能使用到行级锁，否则将使用表锁。    
`死锁`：MyISAM中是一次性获取所需的全部锁，所以不会出现死锁现象；当SQL语句操作了主键索引时，会锁定主键索引；当SQL语句操作了非主键索引时，会锁定非主键索引，然后锁定主键索引；在UPDATE、DELETE操作时，MYSQL不仅会锁定WHERE扫描过的索引，还会锁定相邻的键值（next－key locking）    
产生死锁情况：事务A锁定主键索引，在等待其他相关索引；事务B锁定非主键索引，在等待主键索引。这样就产生了死锁。    
    
**表级锁 － MyISAM**    
`特点`：开销小，加锁快，不会出现死锁；锁粒度最大，发送冲突概率最大，并发度最低。    
    
**页级锁 － BDB**    
`特点`：开销和加锁时间介于表锁和行锁之间；会出现死锁，锁粒度适中，并发度一般。    
    
---    
    
**隔离级别**    
`脏读`：事务A读取了事务B还未提交的修改。    
`不可重复读`：两次相同的查询返回了不同的结果。    
`幻读`：两次相同的查询返回了不同的记录条数。    
    
---    
    
**乐观锁**    
每次获取数据的时候不会上锁，但是在更新的时候会判断一下在此期间是否有人修改过该数据，如果有，则取消当前更新操作。    
    
**悲观锁**    
每次获取数据的时候都会上锁，别人要想更新这个数据需要等待悲观锁介绍后才行。    
    
---    
    
**InnoDB又分共享锁和排它锁**    
`共享锁`：又称为读锁，是读取操作创建的锁，当数据被加上共享锁后，其他session可以并发读取数据，但不能对数据进行修改，不能获取数据上的排他锁，但可以继续加共享锁，只能对数据进行读取操作，不能对数据执行写操作。    
```mysql    
SELECT ＊ FROM table WHERE id = 1 LOCK IN SHARE MODE;    
```    
    
`排他锁`：又称为写锁，当数据被加上排他锁后，其他session不能对该数据进行任何加锁操作，也不能进行读写操作。    
```mysql    
SELECT ＊ FROM table WHERE id = 1 FOR UPDATE;    
```    
    
---    
    
**FOR UPDATE**    
`特点`：仅仅适用于InnoDB，并且需要出现做BEGIN和COMMIT块中（事务）    
    
| 上下文 | 锁状态 | 锁描述 |    
| --- | --- | --- |    
| 明确指定主键并存在该记录 | row lock | 行锁 |    
| 明确制定主角但不存在该记录 | no lock | 无锁 |    
| 无主键 | table lock | 表锁 |    
| 主键不明确 | table lock | 表锁 |    
    
表级锁时，不管是否查询到记录，都会锁定表    
