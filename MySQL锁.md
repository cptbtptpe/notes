
## MySQL锁

**行级锁 － InnoDB**  
*特点*：开销大，加锁慢，容易出现死锁；锁粒度最小，发生冲突概率最低，并发度最高。  
注意事项：行锁说通过给索引加锁来实现的，只有通过索引条件检索的数据才能使用到行级锁，否则将使用表锁。  
*死锁*：MyISAM中是一次性获取所需的全部锁，所以不会出现死锁现象；当SQL语句操作了主键索引时，会锁定主键索引；当SQL语句操作了非主键索引时，会锁定非主键索引，然后锁定主键索引；在UPDATE、DELETE操作时，MYSQL不仅会锁定WHERE扫描过的索引，还会锁定相邻的键值（next－key locking）
产生死锁情况：事务A锁定主键索引，在等待其他相关索引；事务B锁定非主键索引，在等待主键索引。这样就产生了死锁。  

**表级锁 － MyISAM**  
*特点*：开销小，加锁快，不会出现死锁；锁粒度最大，发送冲突概率最大，并发度最低。  

**页级锁 － BDB**  
*特点*：开销和加锁时间介于表锁和行锁之间；会出现死锁，锁粒度适中，并发度一般。  

---

**隔离级别**  
*脏读*：事务A读取了事务B还未提交的修改。  
*不可重复读*：两次相同的查询返回了不同的结果。  
*幻读*：两次相同的查询返回了不同的记录条数。  

---

**乐观锁**  
每次获取数据的时候不会上锁，但是在更新的时候会判断一下在此期间是否有人修改过该数据，如果有，则取消当前更新操作。  

**悲观锁**  
每次获取数据的时候都会上锁，别人要想更新这个数据需要等待悲观锁介绍后才行。

---

**InnoDB又分共享锁和排它锁**  
*共享锁*：又称为读锁，是读取操作创建的锁，当数据被加上共享锁后，其他session可以并发读取数据，但不能对数据进行修改，不能获取数据上的排他锁，但可以继续加共享锁，只能对数据进行读取操作，不能对数据执行写操作。  
```mysql
SELECT ＊ FROM table WHERE id = 1 LOCK IN SHARE MODE;
```

*排他锁*：又称为写锁，当数据被加上排他锁后，其他session不能对该数据进行任何加锁操作，也不能进行读写操作。  
```mysql
SELECT ＊ FROM table WHERE id = 1 FOR UPDATE;
```

---

**FOR UPDATE**  
*特点*：仅仅适用于InnoDB，并且需要出现做BEGIN和COMMIT块中（事务）  

| 上下文 | 锁状态 | 锁描述 |
| --- | --- | --- |
| 明确指定主键并存在该记录 | row lock | 行锁 |
| 明确制定主角但不存在该记录 | no lock | 无锁 |
| 无主键 | table lock | 表锁 |
| 主键不明确 | table lock | 表锁 |

表级锁时，不管是否查询到记录，都会锁定表  
