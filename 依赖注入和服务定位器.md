## 依赖注入和服务定位器  
  
### 依赖倒置原则（ Dependence Inversion Principle, DIP ）  

> `DIP` 是一种软件设计的指导思想。传统软件设计中，上层代码依赖于下层代码，当下层出现变动时， 上层代码也要相应变化，维护成本较高。而 DIP 的核心思想是上层定义接口，下层实现这个接口， 从而使得下层依赖于上层，降低耦合度，提高整个系统的弹性。这是一种经实践证明的有效策略。  
  
### 控制反转（ Inversion of Control, IoC ）  

> `IoC` 就是 `DIP` 的一种具体思路，`DIP` 只是一种理念、思想，而 `IoC` 是一种实现 `DIP` 的方法。 `IoC` 的核心是将类（上层）所依赖的单元（下层）的实例化过程交由第三方来实现。 一个简单的特征，就是类中不对所依赖的单元有诸如 `$component = new yii\component\SomeClass （）` 的实例化语句。  
  
### 依赖注入（ Dependence Injection, DI ）  

> `DI` 是 `IoC` 的一种设计模式，是一种套路，按照 `DI` 的套路，就可以实现 `IoC`，就能符合 `DIP` 原则。 `DI` 的核心是把类所依赖的单元的实例化过程，放到类的外面去实现。  
  
### 控制反转容器（ IoC Container ）  

> 当项目比较大时，依赖关系可能会很复杂。 而 `IoC` `Container `提供了动态地创建、注入依赖单元，映射依赖关系等功能，减少了许多代码量。 `Yii` 设计了一个 `yii\di\Container`  来实现了 `DI Container`。  
  
### 服务定位器（ Service Locator ）  

> `Service Locator` 是 `IoC` 的另一种实现方式， 其核心是把所有可能用到的依赖单元交由 `Service Locator` 进行实例化和创建、配置， 把类对依赖单元的依赖，转换成类对 `Service Locator` 的依赖。 `DI` 与 `Service Locator` 并不冲突，两者可以结合使用。 目前，`Yii 2.0` 把这 `DI` 和 `Service Locator` 这两个东西结合起来使用，或者说通过 `DI` 容器，实现了 `Service Locator`。  
是不是云里雾里的？没错，所谓“高大上”的玩意往往就是这样，看着很炫，很唬人。 卖护肤品的难道会跟你说其实皮肤表层是角质层，不具吸收功能么？这玩意又不考试，大致意会下就可以了。 万一哪天要在妹子面前要装一把范儿的时候，张口也能来这么几个“高大上”就行了。 但具体的内涵，我们还是要要通过下面的学习来加深理解，毕竟要把“高大上”的东西用好，发挥出作用来。  
  
### 依赖注入的实现方法
  
* 构造注入 - `setter`
* 属性注入 - `__construct`
* 接口注入 - `interface`