  
## PHP 手册手记  
  
```php

error_reporting(E_ALL);  
  
function br($num = 1) {  
    echo str_pad(NULL, $num * 4, PHP_EOL);  
}  
  
function hr($num = 1) {  
    echo str_pad(NULL, $num * 4, PHP_EOL);  
}  
  
#-----------------------  
# 如果文件内容是纯 PHP 代码，最好在文件末尾删除 PHP 结束标记。这可以避免在 PHP 结束标记之后万一意外加入了空格或者换行符，会导致 PHP 开始输出这些空白，而脚本中此时并无输出的意图。  
  
  
#-----------------------  
# PHP代码标记的方式  
/**  
 * <?php ?>                             标准支持并推荐  
 * <script language=php></script>       标准支持  
 * <?= ?>                               需要在 php.ini 中开启 short_open_tag 配置  
 * <% %>                                需要在 php.ini 中开启 asp_tags 配置  
 */  
  
  
#-----------------------  
# 自 PHP 5.4 起，短格式的 echo 标记 <?= ?> 总会被识别并且合法，而不管 short_open_tag 的设置是什么。  
  
  
#-----------------------  
# 当 PHP 解释器碰到结束标记 ?> 时就简单地将其后内容原样输出，除非马上紧接换行。  
  
  
#-----------------------  
# 同 C 或 Perl 一样，PHP 需要在每个语句后用分号结束指令。一段 PHP 代码中的结束标记 ?> 隐含表示了一个分号；在一个 PHP 代码段中的最后一行可以不用分号结束。如果后面还有新行，则代码段的结束标记包含了行结束。  
/**  
 * <?php echo "This is a test";?>   // 标准  
 * <?php echo "This is a test" ?>   // 在最后一行没有分号结尾但 PHP 的结束标签补充了这个分号  
 * <?php echo "This is a test";     // 没有结尾标签的 PHP 脚本最后一行需要加上分号  
 */  
  
  
#-----------------------  
# 单行注释仅仅注释到行末或者当前的 PHP 代码块，视乎哪个首先出现。这意味着在 // ... ?> 或者 # ... ?> 之后的 HTML 代码将被显示出来：?> 跳出了 PHP 模式并返回了 HTML 模式，// 或 # 并不能影响到这一点。如果启用了 asp_tags 配置选项，其行为和 // %> 或 # %> 相同。不过，</script> 标记在单行注释中不会跳出 PHP 模式。
  
#-----------------------  
# C 风格的注释在碰到第一个 */ 时结束。要确保不要嵌套 C 风格的注释。试图注释掉一大块代码时很容易出现该错误。  
  
  
#-----------------------  
# 注释一段随时可能要被使用的代码风格  
//*  
echo '这种注释风格可以轻松控制代码，只需要将开头的注释在 /* 和 //* 之间切换即可。';  
hr();  
//*/  
  
  
#-----------------------  
# 注释两段同时只能显示其中一段的注释风格  
/*  
echo '这种注释风格可以轻松控制其中一段代码可用';  
hr();  
/*/  
echo '只需要将开头的注释在 /* 和 //* 之间切换即可。';  
hr();  
//*/  
  
  
#-----------------------  
# 变量类型  
/**  
 * PHP 支持 8 种原始数据类型。  
 *  
 * 四种标量类型：  
 *  
 * boolean（布尔型）  
 * integer（整型）  
 * float（浮点型，也称作 double)  
 * string（字符串）  
 *  
 * 两种复合类型：  
 *  
 * array（数组）  
 * object（对象）  
 *  
 * 最后是两种特殊类型：  
 *  
 * resource（资源）  
 * NULL（无类型）  
 *  
 * 为了确保代码的易读性，本手册还介绍了一些伪类型：  
 *  
 * mixed（混合类型）  
 * number（数字类型）  
 * callback（回调类型）  
 * 以及伪变量 $...。  
 *  
 * 可能还会读到一些关于“双精度（double）”类型的参考。
 * 实际上 double 和 float 是相同的，由于一些历史的原因，这两个名称同时存在。  
 * 变量的类型通常不是由程序员设定的，确切地说，是由 PHP 根据该变量使用的上下文在运行时决定的。  
 */  
  
  
#-----------------------  
# 如果想查看某个表达式的值和类型，用 var_dump() 函数  
# 如果只是想得到一个易读懂的类型的表达方式用于调试，用 gettype() 函数。要判断是不是某个类型用 is_type 函数。  
  
  
#-----------------------  
# 数据类型强制转换  
  
$var = 'hello';  
  
// int  
(int)$var;  
(integer)$var;  
settype($var, 'integer');  
settype($var, 'int');  
intval($var);  
  
// boolean  
(bool)$var;  
(boolean)$var;  
settype($var, 'boolean');  
settype($var, 'bool');  
boolval($var);  
  
// float  
(float)$var;  
(double)$var;  
(real)$var;  
settype($var, 'float');  
floatval($var);  
  
// string  
(string)$var;  
settype($var, 'string');  
strval($var);  
  
// array  
(array)$var;  
settype($var, 'array');  
  
// object  
(object)$var;  
settype($var, 'object');  
  
// NULL  
(unset)$var;  
settype($var, 'null');  
  
// 字符串转为二进制字符串  
(binary)$var;  
// b'world';  
  
  
#-----------------------  
# 加法运算符+，如果任何一个操作数是float，则所有的操作数都被当成float，结果也是float。  
# 否则操作数会被解释为integer，结果也是integer。  
# 注意这并没有改变这些操作数本身的类型；改变的仅是这些操作数如何被求值以及表达式本身的类型。  
  
  
#-----------------------  
# PHP 支持使用和数组下标同样的语法及花括号语法访问字符串下标  
# 用超出字符串长度的下标写入将会拉长该字符串并以空格填充。
# 非整数类型下标会被转换成整数。非法下标类型会产生一个 E_NOTICE 级别错误。  
# 用负数下标写入字符串时会产生一个 E_NOTICE 级别错误，用负数下标读取字符串时返回空字符串。
# 写入时只用到了赋值字符串的第一个字符。用空字符串赋值则赋给的值是 NULL 字符。  
# 用 [] 或 {} 访问任何其它类型（不包括数组或具有相应接口的对象实现）的变量只会无声地返回 NULL。  

$str = 'bar';  
$str[0] = 'c';  
$str{2} = 't';  
echo $str; // car  
hr();  

# PHP5.5以后支持对字符串和数组原型使用以上两种操作  
  
#-----------------------  
# 以下情况为FALSE  
FALSE;  
0;  
0.0;  
'';  
array(); // 空数组  
new stdClass(); // stdClass为php原生无任何属性和方法的类  
NULL;  
new SimpleXMLElement(''); // 创建一个无任何节点的XML对象  

# 1和其它非零值（不论正负）一样，被认为是 TRUE  
  
# 整型值可以为以下情况，前面可以加上可选的符号（- 或者 +）  
# 十进制  
# 以0开头的八进制  
# 以0x开头的十六进制  
# 以0b开头的二进制  
  
  
#-----------------------  
# 32 位平台下的最大值是大约二十亿。  
# 64 位平台下的最大值通常是大约 9E18。  
# PHP 不支持无符号整数。  
  
  
#-----------------------  
# 如果向八进制数传递了一个非法数字（即 8 或 9），则后面其余数字会被忽略  
echo 01090; // 八进制 010 = 十进制 8  
hr();  
  
  
#-----------------------  
# 如果给定的一个数超出了 integer 的范围，将会被解释为 float。同样如果执行的运算结果超出了 integer 范围，也会返回 float。  
  
  
#-----------------------  
# 决不要将未知的分数强制转换为 integer，这样有时会导致不可预料的结果。  
echo (int)((0.1 + 0.7) * 10); // 显示 7!  
hr();  
  
  
#-----------------------  
# 浮点数/整数高精度运算相关类库：GMP函数库、BC数学函数库  
  
  
#-----------------------  
# 浮点型（也叫浮点数 float，双精度数 double 或实数 real）  
# 以十进制能够精确表示的有理数如 0.1 或 0.7，无论有多少尾数都不能被内部所使用的二进制精确表示，因此不能在不丢失一点点精度的情况下转换为二进制的格式。  
# 这就会造成混乱的结果：例如，floor((0.1+0.7)*10) 通常会返回 7 而不是预期中的 8，因为该结果内部的表示其实是类似 7.9999999999999991118...。  
# 所以永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。如果确实需要更高的精度，应该使用任意精度数学函数或者 gmp 函数。  
  
  
#-----------------------  
# 某些数学运算会产生一个由常量 NAN 所代表的结果。  
# 此结果代表着一个在浮点数运算中未定义或不可表述的值。任何拿此值与其它任何值进行的松散或严格比较的结果都是 FALSE。  
# 由于 NAN 代表着任何不同值，不应拿 NAN 去和其它值进行比较，包括其自身，应该用 is_nan() 来检查。  
  
  
#-----------------------  
# 一个字符串 string 就是由一系列的字符组成，其中每个字符等同于一个字节。这意味着 PHP 只能支持 256 的字符集，因此不支持 Unicode 。  
# string 最大可以达到 2GB。  
  
  
#-----------------------  
# 定义string的方法  
  
// 单引号  
$str1 = 'hello';  
  
// 双引号  
$str2 = "hello";  
  
// heredoc 语法结构  
$str3 = <<  
    hello  
EOF;  
$str3 = <<<"EOF"  
    hello  
EOF;  
$str3 = <<<EOF  
    hello  
EOF;  
  
// nowdoc 语法结构  
$str4 = <<<'EOF'  
hello  
EOF;  
  
  
#-----------------------  
# heredoc/nowdoc语法结构的注意点：  
  
# 结束时所引用的标识符必须在该行的第一列，而且，标识符的命名也要像其它标签一样遵守 PHP 的规则：只能包含字母、数字和下划线，并且必须以字母和下划线作为开头。  
# 要注意的是结束标识符这行除了可能有一个分号（;）外，绝对不能包含其它字符。  
# 这意味着标识符不能缩进，分号的前后也不能有任何空白或制表符。  
# 更重要的是结束标识符的前面必须是个被本地操作系统认可的换行，比如在 UNIX 和 Mac OS X 系统中是 \n，而结束定界符（可能其后有个分号）之后也必须紧跟一个换行。  
# Heredocs 结构不能用来初始化类的属性。自 PHP 5.3 起，此限制仅对 heredoc 包含变量时有效。  
  
# 在 PHP 5.3.0 以后，也可以用 Heredoc 结构来初始化静态变量和类的属性和常量  
# 不象 heredoc 结构，nowdoc 结构可以用在任意的静态数据环境中，最典型的示例是用来初始化类的属性或常量  
  
# 不像双引号和 heredoc 语法结构，在单引号字符串中和nowdoc中的变量和特殊字符的转义序列将不会被解析或替换  
  
  
#-----------------------  
# 字符串中放置变量  
$str = 'hello world.';  
echo "I say $str, the first letter is $str[0]";  
br();  
  
# { 和 $ 之间不允许有空格  
echo "He say {$str}";  
hr();  
echo "She say ${str}";  
hr();  
# 对象数组等相关变量都能使用在字符串和heredoc中  
  
  
#-----------------------  
# 函数、方法、静态类变量和类常量只有在 PHP 5 以后才可在 {$} 中使用。然而，只有在该字符串被定义的命名空间中才可以将其值作为变量名来访问。  
# 只单一使用花括号 ({}) 无法处理从函数或方法的返回值或者类常量以及类静态变量的值。  
  
  
#-----------------------  
# 数组 array 总是转换成字符串 "Array"  
# 对象 object 总是被转换成字符串 "Object"  
# 资源 resource 总会被转变成 "Resource id #1"  
  
  
#-----------------------  
# PHP 中的数组实际上是一个有序映射。  
# 映射是一种把 values 关联到 keys 的类型。  
# 此类型在很多方面做了优化，因此可以把它当成真正的数组，或列表（向量），散列表（是映射的一种实现），字典，集合，栈，队列以及更多可能性。  
  
  
#-----------------------  
# 自 5.4 起可以使用短数组定义语法，用 [] 替代 array()  
  
  
#-----------------------  
# 数组的 key 可以是 integer 或者 string。value 可以是任意类型。  
# key 为可选项。如果未指定，PHP 将自动使用之前用过的最大 integer 键名加上 1 作为新的键名。  
  
# 此外 key 会有如下的强制转换：  
# 包含有合法整型值的字符串会被转换为整型。例如键名 "8" 实际会被储存为 8。但是 "08" 则不会强制转换，因为其不是一个合法的十进制数值。  
# 浮点数也会被转换为整型，意味着其小数部分会被舍去。例如键名 8.7 实际会被储存为 8。  
# 布尔值也会被转换成整型。即键名 true 实际会被储存为 1 而键名 false 会被储存为 0。  
# Null 会被转换为空字符串，即键名 null 实际会被储存为 ""。  
# 数组和对象不能被用为键名。坚持这么做会导致警告：Illegal offset type。  
  
# 如果在数组定义中多个单元都使用了同一个键名，则只使用了最后一个，之前的都被覆盖了。  
  
$arr['bar'] = 'hello';  
echo @$arr[bar];  
hr();  
# PHP 自动将裸字符串（没有引号的字符串且不对应于任何已知符号）转换成一个其值为该裸字符串的正常字符串。例如，如果没有常量定义为 bar，PHP 将把它替代为 'bar' 并使用之  
# 这并不意味着总是给键名加上引号。用不着给键名为常量或变量的加上引号，否则会使 PHP 不能解析它们  
  
  
#-----------------------  
# 如果一个 object 类型转换为 array，则结果为一个数组，其单元为该对象的属性。  
# 键名将为成员变量名，不过有几点例外：整数属性不可访问；私有变量前会加上类名作前缀；保护变量前会加上一个 '*' 做前缀。这些前缀的前后都各有一个 NULL 字符。  
class A {  
    private $A; // This will become '\0A\0A'  
}  
  
class B extends A {  
    private $A; // This will become '\0B\0A'  
    public $AA; // This will become 'AA'  
}  
  
var_dump((array)new B());  
hr();  
  
# 上例会有两个键名为 'AA'，不过其中一个实际上是 '\0A\0A'。  
# 将 NULL 转换为 array 会得到一个空的数组。  
  
  
#-----------------------  
# 索引数组为数字当key使用，关联数组为字符串当key使用的，php本身并不区分它们，因为key可以为string或integer  
  
  
#-----------------------  
# 如果将一个对象转换成对象，它将不会有任何变化。  
# 如果其它任何类型的值被转换成对象，将会创建一个内置类 stdClass 的实例。  
# 如果该值为 NULL，则新的实例为空。数组转换成对象将使键名成为属性名并具有相对应的值。  
# 对于任何其它的值，名为 scalar 的成员变量将包含该值。  
  
  
#-----------------------  
# 获取resource资源类型可以用get_resource_type()方法获取  
  
  
#-----------------------  
# 在下列情况下一个变量被认为是 NULL：  
$var = NULL;  
$var;  
unset($var);  
  
  
#-----------------------  
# 使用 (unset) $var 将一个变量转换为 null 将不会删除该变量或 unset 其值。仅是返回 NULL 值而已。  
  
  
#-----------------------  
# 方法标量变量声明的几种情况  
# 不过如果使用 NULL 作为参数的默认值，那么在调用函数的时候依然可以使用 NULL 作为实参。  
# 如果一个类或接口指定了类型约束，则其所有的子类或实现也都如此。  
function a(array $arr) {  
}  
  
function b(classNameB $obj) {  
}  
  
function c(interfaceNameC $interf) {  
}  
  
function d(callable $callback) {  
}  
  
  
#-----------------------  
# 变量正则[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*  
# 在此所说的字母是 a-z，A-Z，以及 ASCII 字符从 127 到 255（0x7f-0xff）。  
# $this 是一个特殊的变量，它不能被赋值。  
# PHP 中的变量用一个美元符号后面跟变量名来表示。变量名是区分大小写的。  
  
  
#-----------------------  
# PHP 指令 register_globals 的值设为 on 将可以使用 $id 代替 $_GET['id'] 等相关获取全局变量的表达式，但并不推荐  
# 超级全局变量不能被用作函数或类方法中的可变变量。$this 变量也是一个特殊变量，不能被动态引用。  
# 尽管超全局变量和 HTTP_*_VARS 同时存在，但是它们并不是同一个变量，所以改变其中一个的值并不会对另一个产生影响。  
  
  
#-----------------------  
# 这里变量 $a 将会在包含文件 b.inc 中生效  
$a = 1;  
@include 'b.inc';  
# PHP 中全局变量在函数中使用时必须声明为 global 或使用超全局变量 $GLOBALS  
# 在函数之外使用 global 关键字不算错。可以用于在一个函数之内包含文件时。  
  
  
#-----------------------  
# 静态变量仅在局部函数域中存在，但当程序执行离开此作用域时，其值并不丢失。如果在声明中用表达式的结果对静态变量赋值会导致解析错误  
# 对于变量的 static 和 global 定义是以引用的方式实现的。  
  
  
#-----------------------  
# 要将可变变量用于数组，必须解决一个模棱两可的问题。  
# 这就是当写下 $$a[1] 时，解析器需要知道是想要 $a[1] 作为一个变量呢，还是想要 $$a 作为一个变量并取出该变量中索引为 [1] 的值。  
# 解决此问题的语法是，对第一种情况用 ${$a[1]}，对第二种情况用 ${$a}[1]。  
  
# 类的属性也可以通过可变属性名来访问。可变属性名将在该调用所处的范围内被解析。  
# 例如，对于 $foo->$bar 表达式，则会在本地范围来解析 $bar 并且其值将被用于 $foo 的属性名。对于 $bar 是数组单元时也是一样。  
  
  
#-----------------------  
# 表单提交的变量名中的点和空格被转换成下划线。例如  变成了 $_REQUEST["a_b_c"]。  
  
  
#-----------------------  
# magic_quotes_gpc 配置指令影响到 Get，Post 和 Cookie 的值。如果打开，值 (It's "PHP!") 会自动转换成 (It\'s \"PHP!\")。  
# 十多年前对数据库的插入需要如此转义，如今已经过时了，应该关闭。  
  
  
#-----------------------  
# Cookies 是 HTTP 信息头中的一部分，因此 SetCookie 函数必须在向浏览器发送任何输出之前调用。  
# 如果想在仅仅一个 cookie 中设定多个值，考虑先在值上使用 serialize() 或 explode()。  
  
  
#-----------------------  
# 常量只能包含标量数据（boolean，integer，float 和 string）。可以定义 resource 常量，但应尽量避免，因为会造成不可预料的结果。  
# 常量是一个简单值的标识符（名字）。如同其名称所暗示的，在脚本执行期间该值不能改变（除了所谓的魔术常量，它们其实不是常量且不区分大小写）。常量默认为大小写敏感。传统上常量标识符总是大写的。  
# 常量正则[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]* (与变量一致)  
  
# 常量和变量有如下不同：  
/**  
 * 常量前面没有美元符号（$）；  
 * 常量只能用 define() 函数定义，而不能通过赋值语句；  
 * 常量可以不用理会变量的作用域而在任何地方定义和访问；  
 * 常量一旦定义就不能被重新定义或者取消定义；  
 * 常量的值只能是标量。  
 */  
  
  
#-----------------------  
# 和使用 define() 来定义常量相反的是，使用 const 关键字定义常量必须处于最顶端的作用区域，因为用此方法是在编译时定义的。  
# 这就意味着不能在函数内，循环内以及 if 语句之内用 const 来定义常量。  
  
  
#-----------------------  
# 如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换为数值并且比较按照数值来进行。  
# 此规则也适用于 switch 语句。当用 === 或 !== 进行比较时则不进行类型转换，因为此时类型和数值都要比对。  
  
  
#-----------------------  
# 可以省略三元运算符中间那部分。表达式 expr1 ?: expr3 在 expr1 求值为 TRUE 时返回 expr1，否则返回 expr3。  
# 注意三元运算符是个语句，因此其求值不是变量，而是语句的结果。  
# 如果想通过引用返回一个变量这点就很重要。在一个通过引用返回的函数中语句 return $var == 42 ? $a : $b; 将不起作用，以后的 PHP 版本会为此发出一条警告。  
  
  
#-----------------------  
# PHP 支持一个错误控制运算符：@。当将其放置在一个 PHP 表达式之前，该表达式可能产生的任何错误信息都被忽略掉。  
# 如果用 set_error_handler() 设定了自定义的错误处理函数，仍然会被调用，但是此错误处理函数可以（并且也应该）调用 error_reporting()，而该函数在出错语句前有 @ 时将返回 0。  
# 如果激活了 track_errors 特性，表达式所产生的任何错误信息都被存放在变量 $php_errormsg 中。此变量在每次出错时都会被覆盖，所以如果想用它的话就要尽早检查。  
  
# @ 运算符只对表达式有效。对新手来说一个简单的规则就是：如果能从某处得到值，就能在它前面加上 @ 运算符。  
# 例如，可以把它放在变量，函数和 include 调用，常量，等等之前。不能把它放在函数或类的定义之前，也不能用于条件结构例如 if 和 foreach 等。  
  
  
#-----------------------  
# PHP 支持一个执行运算符：反引号（``）。  
# 注意这不是单引号！PHP 将尝试将反引号中的内容作为外壳命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出）。  
# 使用反引号运算符“`”的效果与函数 shell_exec() 相同。  
$output = `ls -al`;  
echo "<pre>ls命令 $output</pre>";  
hr();  
# 反引号运算符在激活了安全模式或者关闭了 shell_exec() 时是无效的。  
# 与其它某些语言不同，反引号不能在双引号字符串中使用。  
  
  
#-----------------------  
# 递增／递减运算符不影响布尔值。递减 NULL 值也没有效果，但是递增 NULL 的结果是 1。  
$add = NULL;  
echo ++$add;  
br();  
  
$add = TRUE;  
echo ++$add;  
hr();  
  
  
#-----------------------  
# "||" 比 "or" 的优先级高  
# 赋值符号”=”的优先级低于逻辑与符号”||”，但高于逻辑与符号”or”  
# "&&" 比 "and" 的优先级高  
# 赋值符号”=”的优先级低于逻辑与符号”&&”，但高于逻辑与符号”and”  
  
$a = 2;  
$b = 3;  
  
$c = $a && $b;  
var_dump($c); // TRUE  
br();  
  
$c = $a and $b;  
var_dump($c); // 2 表达式演化==> ($c = $a) and $b;  
hr();  
  
  
#-----------------------  
# 数组相加运算  
# + 运算符把右边的数组元素附加到左边的数组后面，两个数组中都有的键名，则只用左边数组中的，右边的被忽略。  
$a = [  
    'name' => 'Leon',  
    'age' => 26  
];  
$b = [  
    'name' => 'List',  
    'work' => 'IT'  
];  
var_dump($a + $b); // ['name' => 'Leon', 'age' => 26, 'work' => 'IT'];  
hr();  
  
  
#-----------------------  
# instanceof 用于确定一个 PHP 变量是否属于某一类 class 的实例  
# instanceof　也可用来确定一个变量是不是继承自某一父类的子类的实例  
# 检查一个对象是否不是某个类的实例，可以使用逻辑运算符 not。  
# 虽然 instanceof 通常直接与类名一起使用，但也可以使用对象或字符串变量  
# 如果被检测的变量不是对象，instanceof 并不发出任何错误信息而是返回 FALSE。不允许用来检测常量。  
# is_a() — 如果对象属于该类或该类是此对象的父类则返回 TRUE  
  
  
#-----------------------  
# PHP 提供了一些流程控制的替代语法，包括 if，while，for，foreach 和 switch。  
# 替代语法的基本形式是把左花括号（{）换成冒号（:），把右花括号（}）分别换成 endif;，endwhile;，endfor;，endforeach; 以及 endswitch;。  
# 不支持在同一个控制块内混合使用两种语法。  
  
# 流程语句的另类写法  
$result = TRUE;  
if ($result):  
    echo 'Sucess';  
else:  
    echo 'Fail';  
endif;  
hr();  
  
  
#-----------------------  
# 遍历的另类写法  
$user = [  
    'first' => 'Leon',  
    'second' => 'Lisa'  
];  
# 方式一  
foreach ($user as $key => $val):  
    echo $key . ' => ' . $val;  
    br();  
endforeach;  
hr();  
  
  
#-----------------------  
# for循环的四种写法  
# 方式  
for ($i = 1; $i <= 3; $i++) {  
    echo $i;  
    br();  
}  
hr();  
  
# 方式二  
for ($i = 1; ; $i++) {  
    if ($i > 3) {  
        break;  
    }  
    echo $i;  
    br();  
}  
hr();  
  
# 方式三  
$i = 1;  
for (; ;) {  
    if ($i > 3) {  
        break;  
    }  
    echo $i;  
    br();  
    $i++;  
}  
hr();  
  
# 方式四  
for ($i = 1, $j = 0; $i <= 3; $j += $i, print $i, br(), $i++) {  
    ;  
}  
hr();  
  
  
#-----------------------  
# 在同一个 if 语句中可以有多个 elseif 部分，其中第一个表达式值为 TRUE（如果有的话）的 elseif 部分将会执行。  
# 在 PHP 中，也可以写成“else if”（两个单词），它和“elseif”（一个单词）的行为完全一样。  
# 句法分析的含义有少许区别（如果你熟悉 C 语言的话，与之行为相同），但是底线是两者会产生完全一样的行为。  
  
# elseif 的语句仅在之前的 if 和所有之前 elseif 的表达式值为 FALSE，并且当前的 elseif 表达式值为 TRUE 时执行。  
# 必须要注意的是 elseif 与 else if 只有在类似上例中使用花括号的情况下才认为是完全相同。如果用冒号来定义 if/elseif 条件，那就不能用两个单词的 else if，否则 PHP 会产生解析错误。  
  
  
#-----------------------  
# 当 foreach 开始执行时，数组内部的指针会自动指向第一个单元。这意味着不需要在 foreach 循环之前调用 reset()。  
# 由于 foreach 依赖内部数组指针，在循环中修改其值将可能导致意外的行为。  
  
# 数组最后一个元素的 $value 引用在 foreach 循环之后仍会保留。建议使用 unset() 来将其销毁。  
foreach ([  
             1,  
             2,  
             3,  
             4  
         ] as &$value) {  
    $value *= 2;  
}  
echo $value;  
hr();  
  
  
#-----------------------  
# foreach 不支持用“@”来抑制错误信息的能力。  
# 用 list() 给嵌套的数组解包 (比较适合二维数组)  
$arr = [  
    [  
        1,  
        2  
    ],  
    [  
        3,  
        4  
    ]  
];  
foreach ($arr as list($first, $last)) {  
    echo $first . ' and ' . $last;  
    br();  
}  
hr();  
  
  
#-----------------------  
# break 结束当前 for，foreach，while，do-while 或者 switch 结构的执行。  
# break 可以接受一个可选的数字参数来决定跳出几重循环。  
  
# continue 在循环结构用用来跳过本次循环中剩余的代码并在条件求值为真时开始执行下一次循环。  
# switch 语句被认为是可以使用 continue 的一种循环结构。  
# continue 接受一个可选的数字参数来决定跳过几重循环到循环结尾。默认值是 1，即跳到当前循环末尾。  
# 注意和其它语言不同，continue 语句作用到 switch 上的作用类似于 break。如果在循环中有一个 switch 并希望 continue 到外层循环中的下一轮循环，用 continue 2。  
  
  
#-----------------------  
# switch中允许使用分号代替 case 语句后的冒号  
  
  
#-----------------------  
# 如果在一个函数中调用 return 语句，将立即结束此函数的执行并将它的参数作为函数的值返回。return 也会终止 eval() 语句或者脚本文件的执行。  
# 如果在全局范围中调用，则当前脚本文件中止运行。如果当前脚本文件是被 include 的或者 require 的，则控制交回调用文件。  
# 此外，如果当前脚本是被 include 的，则 return 的值会被当作 include 调用的返回值。  
# 如果在主脚本文件中调用 return，则脚本中止运行。  
# 如果当前脚本文件是在 php.ini 中的配置选项 auto_prepend_file 或者 auto_append_file 所指定的，则此脚本文件中止运行。  
$code = <<  
if (0) :  
    return 'TRUE';  
else :  
    return 'FALSE';  
endif;  
EOF;  
echo eval($code);  
hr();  
  
  
#-----------------------  
# 注意既然 return 是语言结构而不是函数，因此其参数没有必要用括号将其括起来。通常都不用括号，实际上也应该不用，这样可以降低 PHP 的负担。  
# 如果没有提供参数，则一定不能用括号，此时返回 NULL。如果调用 return 时加上了括号却又没有参数会导致解析错误。  
# 当用引用返回值时永远不要使用括号，这样行不通。只能通过引用返回变量，而不是语句的结果。如果使用 return ($a); 时其实不是返回一个变量，而是表达式 ($a) 的值（当然，此时该值也正是 $a 的值）。  
  
  
#-----------------------  
# require 和 include 几乎完全一样，除了处理失败的方式不同之外。require 在出错时产生 E_COMPILE_ERROR 级别的错误。换句话说将导致脚本中止而 include 只产生警告（E_WARNING），脚本会继续运行。  
# 当一个文件被包含时，其中所包含的代码继承了 require/include 所在行的变量范围。从该处开始，调用文件在该行处可用的任何变量在被调用的文件中也都可用。不过所有在包含文件中定义的函数和类都具有全局作用域。  
# 当一个文件被包含时，语法解析器在目标文件的开头脱离 PHP 模式并进入 HTML 模式，到文件结尾处恢复。由于此原因，目标文件中需要作为 PHP 代码执行的任何代码都必须被包括在有效的 PHP 起始和结束标记之中。  
# 在失败时 include 返回 FALSE 并且发出警告。成功的包含则返回 1，除非在包含文件中另外给出了返回值。可以在被包括的文件中使用 return 语句来终止该文件中程序的执行并返回调用它的脚本。  
  
  
#-----------------------  
# goto 操作符可以用来跳转到程序中的另一位置。  
# 该目标位置可以用目标名称加上冒号来标记，而跳转指令是 goto 之后接上目标位置的标记。  
# PHP 中的 goto 有一定限制，目标位置只能位于同一个文件和作用域，也就是说无法跳出一个函数或类方法，也无法跳入到另一个函数。  
# 也无法跳入到任何循环或者 switch 结构中。可以跳出循环或者 switch，通常的用法是用 goto 代替多层的 break。  
  
  
#-----------------------  
# 函数命名正则 [a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*  
# PHP 不支持函数重载，也不可能取消定义或者重定义已声明的函数。  
# 函数名是大小写无关的，不过在调用函数的时候，使用其在定义时相同的形式是个好习惯。  
  
  
#-----------------------  
# PHP 不支持函数重载，也不可能取消定义或者重定义已声明的函数。  
# 函数名是大小写无关的，不过在调用函数的时候，使用其在定义时相同的形式是个好习惯。  
# 尽量避免递归函数／方法调用超过 100-200 层，因为可能会使堆栈崩溃从而使当前脚本终止。 无限递归可视为编程错误。  
  
  
#-----------------------  
# 默认情况下，函数参数通过值传递（因而即使在函数内部改变参数的值，它并不会改变函数外部的值）。如果希望允许函数修改它的参数值，必须通过引用传递参数。  
# 如果想要函数的一个参数总是通过引用传递，可以在函数定义中该参数的前面加上符号 &  
# 自 PHP 5 起，传引用的参数也可以有默认值。  
  
  
#-----------------------  
# 如果省略了 return，则返回值为 NULL。  
# 从函数返回一个引用，必须在函数声明和指派返回值给一个变量时都使用引用运算符 &  
  
  
#-----------------------  
# 闭包函数也可以作为变量的值来使用。PHP 会自动把此种表达式转换成内置类 Closure 的对象实例。把一个 closure 对象赋值给一个变量的方式与普通变量赋值的语法是一样的，最后也要加上分号  
# Closure 类用于代表 匿名函数 的类，匿名函数（在 PHP 5.3 中被引入）会产生这个类型的对象。  
  
# use 关键字为继承父作用域  
# 闭包可以从父作用域中继承变量。 任何此类变量都应该用 use 语言结构传递进去。  
# 这些变量都必须在函数或类的头部声明。从父作用域中继承变量与使用全局变量是不同的。  
# 全局变量存在于一个全局的范围，无论当前在执行的是哪个函数。而 闭包的父作用域是定义该闭包的函数（不一定是调用它的函数）  
$name = 'Leon';  
$echo = function () use ($name) {  
    echo '我的名字叫：' . $name;  
    br();  
};  
$echo();  
  
$name = 'Lisa'; // 需要本次修改生效需将匿名函数定义在当前变量下，或者将use ($name) 改为 use (&$name)  
$echo();  
hr();  
  
  
#-----------------------  
# PHP 对待对象的方式与引用和句柄相同，即每个变量都持有对象的引用，而不是整个对象的拷贝。  
# 每个类的定义都以关键字 class 开头，后面跟着类名，后面跟着一对花括号，里面包含有类的属性与方法的定义。  
# 类名正则[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*  
# 一个类可以包含有属于自己的常量，变量（称为“属性”）以及函数（称为“方法”）。  
# $this伪变量的动态绑定，静态调用类方法时$this关键字将报错  
class One {  
    public function name() {  
        echo "print by __CLASS__: " . __CLASS__;  
        br();  
        echo "print by get_class(): " . get_class($this);  
        br();  
    }  
  
    public function getSelf() {  
        echo 'parint by new self(): ' . get_class(new self());  
        br();  
    }  
  
    public function getSatic() {  
        echo 'parint by new static(): ' . get_class(new static());  
        br();  
    }  
}  
  
class Two extends One {  
    public function name() {  
        parent::name();  
        br();  
    }  
  
    public function getParent() {  
        echo 'parint by new parent(): ' . get_class(new parent());  
        br();  
    }  
}  
  
(new One())->name();  
hr();  
(new Two())->name();  
hr();  
  
  
#-----------------------  
# 要创建一个类的实例，必须使用 new 关键字。当创建新对象时该对象总是被赋值，除非该对象定义了构造函数并且在出错时抛出了一个异常。类应在被实例化之前定义（某些情况下则必须这样）。  
# 在类定义内部，可以用 new self 和 new parent 和 new static 创建新对象。  
# 当把一个对象已经创建的实例赋给一个新变量时，新变量会访问同一个实例，就和用该对象赋值一样。此行为和给函数传递入实例时一样。可以用clone给一个已创建的对象建立一个新实例。  
  
# self - 就是这个类，是当前代码所属的类。  
# parent - 就是所继承的父类  
# static - 有点像$this的意思，从堆内存中提取出来，访问的是当前实例化的那个类，那么 static 代表的就是那个类。  
$name = 'Two';  
$obj = new $name();  
  
$obj->getSelf();  
hr();  
$obj->getParent();  
hr();  
$obj->getSatic();  
hr();  
  
  
#-----------------------  
# 一个类可以在声明中用 extends 关键字继承另一个类的方法和属性。PHP不支持多重继承，一个类只能继承一个基类。  
# 被继承的方法和属性可以通过用同样的名字重新声明被覆盖。但是如果父类定义方法时使用了 final，则该方法不可被覆盖。可以通过 parent:: 来访问被覆盖的方法或属性。  
# 当覆盖方法时，参数必须保持一致否则 PHP 将发出 E_STRICT 级别的错误信息。但构造函数例外，构造函数可在被覆盖时使用不同的参数。  
# 覆盖方法时，子类和父类的方法参数个数必须一致，有默认值的参数视为无该参数对待来比较。  
# 自 PHP 5.5 起，关键词 class 也可用于类名的解析。使用 类名::class 你可以获取一个字符串，包含了该类名的完全限定名称。这对使用了 命名空间 的类尤其有用。  
class First {  
    public function name() {  
    }  
}  
  
class Last extends First {  
    //public function name($a) {}  
}  
  
  
#-----------------------  
# 类的变量成员叫做“属性”，或者叫“字段”、“特征”，在本文档统一称为“属性”。  
# 属性声明是由关键字 public，protected 或者 private 开头，然后跟一个普通的变量声明来组成。  
# 属性中的变量可以初始化，但是初始化的值必须是常数，这里的常数是指 PHP 脚本在编译阶段时就可以得到其值，而不依赖于运行时的信息才能求值。  
# 如果直接使用 var 声明属性，而没有用 public，protected 或 private 之一，PHP 5 会将其视为 public。  
  
  
#-----------------------  
# 在类的成员方法里面，可以用 ->（对象运算符）：$this->property（其中 property 是该属性名）这种方式来访问非静态属性。  
# 静态属性则是用 ::（双冒号）：self::$property 来访问。更多静态属性与非静态属性的区别参见 Static 关键字。  
# 在 PHP 5.3.0 及之后，类属性可用nowdoc方式声明，heredoc则不行 （跟 heredocs 不同，nowdocs 可在任何静态数据上下文中使用，包括属性声明。）  
  
  
#-----------------------  
# spl_autoload_register() 提供了一种更加灵活的方式来实现类的自动加载。因此，不再建议使用 __autoload() 函数，在以后的版本中它可能被弃用。  
# 自动加载不可用于 PHP 的 CLI 交互模式。  
# 如果类名比如被用于 call_user_func()，则它可能包含一些危险的字符，比如 ../。 建议您在这样的函数中不要使用用户的输入，起码需要在 __autoload() 时验证下输入。  
  
  
#-----------------------  
# 如果子类中定义了构造函数则不会隐式调用其父类的构造函数。  
# 要执行父类的构造函数，需要在子类的构造函数中调用 parent::__construct()。  
# 如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承（假如没有被定义为 private 的话）。  
# 自 PHP 5.3.3 起，在命名空间中，与类名同名的方法不再作为构造函数。这一改变不影响不在命名空间中的类。  
class Father {  
    //*  
    public function __construct() {  
        echo 'this is __construct() of class Father.';  
        br();  
    }  
    /*/  
    public function father() {  
        echo 'this is father() of class Father.';  
        br();  
    }  
    //*/  
}  
  
class Son extends Father {  
    /*  
    public function __construct() {  
        echo 'this is __construct() of class Son.';  
        br();  
    }  
    /*\/  
    public function son() {  
        echo 'this is son() of class Son.';  
    }  
    //*/  
}  
  
new Son();  
hr();  
  
# 以上示例得出结论  
/**  
 * 以下提到旧式构造函数处解释为和类名同名的类方法 (不区分大小写)  
 *  
 * 1. 为了实现向后兼容性，PHP5 在类中找不到 __construct() 函数并且也没有从父类继承一个的话，它就会尝试寻找旧式的构造函数。  
 * 2. 同一个类中 __construct() 方法比 旧式构造函数 优先级要高。  
 * 3. Son类中没有 __construct 和 旧式构造函数 时，new Son() 是将会自动继承调用父类的 __construct() 或 父类的旧式构造函数。  
 */  

# 所谓的 旧式构造函数 是与类名同名的类方法  
  
#-----------------------  
# 析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。  
# 析构函数也和构造函数一样具有以上例举的特性。  
# 析构函数即使在使用 exit() 终止脚本运行时也会被调用。在析构函数中调用 exit() 将会中止其余关闭操作的运行。  
class Over {  
    public function __destruct() {  
        echo '这里进行垃圾回收';  
    }  
}  
  
//*  
new Over(); // new完对象后直接垃圾回收  
/*/  
$obj = new Over(); // exit后并执行垃圾回收  
//*/  
// exit('这里终止了脚本');  
hr();  
  
# 注意：顺序不一致  
# 试图在析构函数（在脚本终止时被调用）中抛出一个异常会导致致命错误。  
  
  
#-----------------------  
# 对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的。  
# 被定义为 public 公有的类成员可以在任何地方被访问。  
# 被定义为 protected 受保护的类成员则可以被其自身以及其子类和父类访问。  
# 被定义为 private 私有的类成员则只能被其定义所在的类访问。  
  
# 类中的方法或属性可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有。  
# 一个类的对象即使不是同一个实例也可以互相访问对方的私有与受保护成员。这是由于在这些对象的内部具体实现的细节都是已知的。  
  
  
#-----------------------  
# 除非使用了自动加载，否则一个类必须在使用之前被定义。如果一个类扩展了另一个，则父类必须在子类之前被声明。此规则适用于类继承其它类与接口。  
  
  
#-----------------------  
# 范围解析操作符（也可称作 Paamayim Nekudotayim）或者更简单地说是一对冒号，可以用于访问静态成员，类常量，还可以用于覆盖类中的属性和方法。  
# 自 PHP 5.3.0 起，可以通过变量来引用类，该变量的值不能是关键字（如 self，parent 和 static）。  
  
  
#-----------------------  
# 本页说明了用 static 关键字来定义静态方法和属性。static 也可用于定义静态变量以及后期静态绑定。参见上述页面了解 static 在其中的用法。  
# 自 PHP 5.3.0 起，PHP 增加了一个叫做后期静态绑定的功能，用于在继承范围内引用静态调用的类。  
  
# 准确说，后期静态绑定工作原理是存储了在上一个“非转发调用”（non-forwarding call）的类名。  
# 当进行静态方法调用时，该类名即为明确指定的那个（通常在 :: 运算符左侧部分）；当进行非静态方法调用时，即为该对象所属的类。  
# 所谓的“转发调用”（forwarding call）指的是通过以下几种方式进行的静态调用：self::，parent::，static:: 以及 forward_static_call()。  
# 可用 get_called_class() 函数来得到被调用的方法所在的类名，static:: 则指出了其范围。  
# “后期绑定”的意思是说，static:: 不再被解析为定义当前方法所在的类，而是在实际运行时计算的。也可以称之为“静态绑定”，因为它可以用于（但不限于）静态方法的调用。  
# 使用 self:: 或者 __CLASS__ 对当前类的静态引用，取决于定义当前方法所在的类  
# 在非静态环境下，所调用的类即为该对象实例所属的类。由于 $this-> 会在同一作用范围内尝试调用私有方法，而 static:: 则可能给出不同结果。另一个区别是 static:: 只能用于静态属性。  
# 后期静态绑定的解析会一直到取得一个完全解析了的静态调用为止。另一方面，如果静态调用使用 parent:: 或者 self:: 将转发调用信息。  
  
  
#-----------------------  
# 声明类属性或方法为静态，就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）  
# 该处所说的调用是静态属性不可以由对象通过 -> 操作符来访问，并不包括范围解析操作符::  
  
# 由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。  
# 就像其它所有的 PHP 静态变量一样，静态属性只能被初始化为文字或常量，不能使用表达式。所以可以把静态属性初始化为整数或数组，但不能初始化为另一个变量或函数返回值，也不能指向一个对象。  
class Hello {  
    const CONSTANT = '类常量';  
    public $normal = '正常类属性';  
    static public $staticed = '静态类属性';  
  
    public function normal() {  
        echo '正常类方法';  
        br();  
    }  
  
    static public function staticed() {  
        echo '静态类方法';  
        br();  
    }  
}  
  
$hello = new Hello();  
  
// 访问非静态属性  
echo $hello->normal;  
hr();  
  
// 访问静态属性  
echo $hello::$staticed;  
//echo $hello->staticed; // 静态属性不能通过一个类已实例化的对象来访问(静态方法可以$obj->)，但可以使用 $obj:: 访问，见上例  
br();  
echo Hello::$staticed;  
hr();  
  
// 访问非静态方法  
$hello->staticed();  
hr();  
  
// 访问静态方法  
$hello->staticed();  
$hello::staticed();  
Hello::staticed();  
hr();  
  
// 访问常量  
echo $hello::CONSTANT;  
br();  
echo Hello::CONSTANT;  
  
hr();  
  
  
#-----------------------  
# 定义为抽象的类不能被实例化。  
# 任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。  
# 被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现（花括号及方法体）。  
# 继承一个抽象类的时候，子类必须定义父类中的所有抽象方法。另外，这些方法的访问控制必须和父类中一样（或者更为宽松如抽象是用protected，实现必须为protected或public）。  
# 抽象方法的调用方式必须匹配，即类型和所需参数数量必须一致。子类定义了一个可选参数，而父类抽象方法的声明里没有，则两者的声明并无冲突。  
abstract class Persion {  
    // 类中只要有一个方法被定义为抽象方法，该所属类就必须定义为抽象类  
    // 抽象方法只能定义参数，不能有具体的实现  
    abstract protected function run($speed);  
  
    // 普通方法在子类中可以选择性的重写  
    public function eat() {  
        echo '人类都会吃东西';  
        br();  
    }  
}  
  
class Man extends Persion {  
    // 此处只能声明为 protected 或 public 声明为 private 会得到一个 Fatal 级别的错误  
    // 不声明此方法将会得到一个 Fatal 级别的错误  
    // 不声明此方法的参数将会得到一个 Fatal 级别的错误  
    public function run($speed) {  
        echo '男人的奔跑平均速度是：' . $speed;  
        br();  
    }  
}  
  
  
#-----------------------  
# 使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。  
# 接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。  
# 接口中定义的所有方法都必须是公有，这是接口的特性。  
# 要实现一个接口，使用 implements 操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称（实现多个接口时，接口中的方法不能有重名）。  
# 接口也可以继承，通过使用 extends 操作符  
# 类要实现接口，必须使用和接口中所定义的方法完全一致的方式。否则会导致致命错误。  
# 接口中也可以定义常量。接口常量和类常量的使用完全相同，但是不能被子类或子接口所覆盖  
interface WebService {  
    const XML = 'XML文件路径常量';  
  
    public function webService();  
}  
  
interface Api extends WebService {  
    public function timeout($time);  
}  
  
interface Soap {  
    public function soap();  
}  
  
class Object implements Api, Soap {  
    public function webService() {  
        echo '通过webService请求api';  
        br();  
    }  
  
    public function soap() {  
        echo '通过soap请求api';  
        br();  
    }  
  
    public function timeout($time) {  
        echo '设置timeout=' . $time;  
        br();  
    }  
}  
  
# 继承WebService接口的接口或实现该接口的类中不允许重写常量XML，这将产生一个 Fatal 级别的错误  
  
$www = new Object();  
echo 'interface接口常量：' . WebService::XML;  
br();  
echo $www::XML;  
br();  
$www->timeout(3000);  
$www->webService();  
$www->soap();  
hr();  
  
  
#-----------------------  
# Traits 是一种为类似 PHP 的单继承语言而准备的代码复用机制。Trait 为了减少单继承语言的限制，使开发人员能够自由地在不同层次结构内独立的类中复用方法集。  
# Trait 和一个类相似，但仅仅旨在用细粒度和一致的方式来组合功能。Trait 不能通过它自身来实例化。它为传统继承增加了水平特性的组合；也就是说，应用类的成员不需要继承。  
# 从基类继承的成员被 trait 插入的成员所覆盖。优先顺序是来自当前类的成员覆盖了 trait 的方法，而 trait 则覆盖了被继承的方法。  
# 优先级 派生类 > Trait > 基类 并会以此覆盖  
# 通过逗号分隔，在 use 声明列出多个 trait，可以都插入到一个类中。  
  
# 如果两个 trait 都插入了一个同名的方法，如果没有明确解决冲突将会产生一个致命错误。  
# 为了解决多个 trait 在同一个类中的命名冲突，需要使用 insteadof 操作符来明确指定使用冲突方法中的哪一个。  
# 以上方式仅允许排除掉其它方法，as 操作符可以将其中一个冲突的方法以另一个名称来引入。  
# 使用 as 语法还可以用来调整方法的访问控制。  
  
# 正如类能够使用 trait 一样，其它 trait 也能够使用 trait。在 trait 定义时通过使用一个或多个 trait，它能够组合其它 trait 中的部分或全部成员。  
# 为了对使用的类施加强制要求，trait 支持抽象方法的使用。  
trait Say {  
    public function speed() {  
        echo 'Trait Say say fast.';  
        br();  
    }  
}  
  
trait Eat {  
    public function eat($food) {  
        echo 'Trait Eat eat ' . $food . '.';  
        br();  
    }  
  
    public function speed() {  
        echo 'Trait Eat eat fast.';  
        br();  
    }  
}  
  
class Human {  
    use Say, Eat {  
        Say::speed insteadof Eat;  
        Eat::speed insteadof Say; // 以上两条只能存在一个在不取别名的情况下，并且 insteadof 要指明冲突的Trait  
        Say::speed as protected saySpeed;  
        Eat::speed as private eatSpeed;  
    }  
  
    public function __construct() {  
        $this->saySpeed();  
        $this->eatSpeed();  
        $this->eat('apple');  
    }  
}  
  
new Human();  
hr();  
  
  
#-----------------------  
# Java 的重载和重写  
  
# Java 的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。  
# 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。  
  
# Java 的方法重写，又称为方法覆盖  
# 父类与子类之间的多态性，对父类的函数进行重新定义。  
# 如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。  
  
  
#-----------------------  
# PHP所提供的"重载"（overloading）是指动态地"创建"类属性和方法。我们是通过魔术方法（magic methods）来实现的。  
# 当调用当前环境下未定义或不可见的类属性或方法时，重载方法会被调用。  
# 所有的重载方法都必须被声明为 public。  
# PHP中的"重载"与其它绝大多数面向对象语言不同。传统的"重载"是用于提供多个同名的类方法，但各方法的参数类型和个数不同。  
  
# 属性重载  
/**  
 * __set()      在给不可访问属性赋值时调用  
 * __get()      读取不可访问属性的值时  
 * __isset()    当对不可访问属性调用 isset() 或 empty() 时  
 * __unset()    当对不可访问属性调用 unset() 时  
 */  
# 因为 PHP 处理赋值运算的方式，__set() 的返回值将被忽略。类似的, 在下面这样的链式赋值中，__get() 不会被调用：$a = $obj->b = 8;  
# 在除 isset() 外的其它语言结构中无法使用重载的属性，这意味着当对一个重载的属性使用 empty() 时，重载魔术方法将不会被调用。为避开此限制，必须将重载属性赋值到本地变量再使用 empty()。  
  
  
#-----------------------  
# 方法重载  
/**  
 * __call()         在对象中调用一个不可访问方法时  
 * __callStatic()   用静态方式中调用一个不可访问方法时  
 */  
  
  
#-----------------------  
# PHP 5 提供了一种定义对象的方法使其可以通过单元列表来遍历，例如用 foreach 语句。默认情况下，所有可见属性都将被用于遍历。  
# PHP 还提供了遍历 接口 Iterator  
# 可以用 IteratorAggregate 接口以替代实现所有的 Iterator 方法。IteratorAggregate 只需要实现一个方法 IteratorAggregate::getIterator()，其应返回一个实现了 Iterator 的类的实例。  
# 更多遍历的示例见 SPL 扩展  
  
  
#-----------------------  
# PHP 将所有以 __（两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 __ 为前缀。  
/**  
 * __sleep()  
 *  
 * serialize()  函数会检查类中是否存在一个魔术方法 __sleep()。  
 *              如果存在，该方法会先被调用，然后才执行序列化操作。  
 *              此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。  
 *              如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。  
 * __sleep()    不能返回父类的私有成员的名字。这样做会产生一个 E_NOTICE 级别的错误。
 *              可以用 Serializable 接口来替代。  
 * __sleep()    方法常用于提交未提交的数据，或类似的清理操作。
 *              同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。  
 */  
  
/**  
 * __wakeup()  
 *  
 * unserialize()会检查是否存在一个 __wakeup() 方法。  
 *              如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。  
 * __wakeup()   经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。  
 */  
  
/**  
 * __toString()  
 *  
 * __toString() 方法用于一个类被当成字符串时应怎样回应。  
 *              例如 echo $obj; 应该显示些什么。
 *              此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误。 
 *              不能在 __toString() 方法中抛出异常。这么做会导致致命错误。  
 */  
  
/**  
 * __invoke()  
 *  
 *              本特性只在 PHP 5.3.0 及以上版本有效。  
 *              当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。  
 */  
  
/**  
 * __set_state()  
 *  
 *              自 PHP 5.1.0 起当调用 var_export() 导出类时，此静态 方法会被调用。  
 *              本方法的唯一参数是一个数组，其中包含按 array('property' => value, ...) 格式排列的类属性。  
 */  
  
/**  
 * __debugInfo()  
 *  
 *              本特性只在 PHP 5.6.0 及以上版本有效。  
 *              当使用 var_dump() 函数打印对象是将调用该方法  
 *              当该魔术方法没有定义使用 var_dump() 将所有的公共、保护和私有属性都打印显示。  
 */  
  
  
#-----------------------  
# PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。  
# 属性不能被定义为 final，只有类和方法才能被定义为 final。  
  
  
#-----------------------  
# 对象复制可以通过 clone 关键字来完成（如果可能，这将调用对象的 __clone() 方法）。对象中的 __clone() 方法不能被直接调用。  
# 当对象被 clone 复制后，PHP 5 会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性 仍然会是一个指向原来的变量的引用。  
# 当复制完成时，如果定义了 __clone() 方法，则新创建的对象（复制生成的对象）中的 __clone() 方法会被调用，可用于修改属性的值（如果有必要的话）。  
  
# 我们使用clone来复制对象，这种复制叫做“浅复制”：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。  
# 也就是说，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。  
# 相对于“浅复制”，当然也有一个“深复制”：被复制的对象的所有的变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。也就是说，深复制把要复制的对象所引用的对象都复制了一遍。  
  
# 深克隆  
# 使用 __clone() 魔术方法一一对引用类型的属性进行处理，太麻烦，不推荐该方法  
# PHP有串行化(serialize)和反串行化(unserialize)函数，我们只需要用serialize()将一个对象写入一个流，然后从流中读回对象，那么对象就被复制了。在JAVA语言里面，这个过程叫做“冷藏”和“解冻”。  
# $obj2 = unserialize(serialize($obj1))  
  
  
#-----------------------  
# 当使用比较运算符（==）比较两个对象变量时，比较的原则是：如果两个对象的属性和属性值 都相等，而且两个对象是同一个类的实例，那么这两个对象变量相等。  
# 而如果使用全等运算符（===），这两个对象变量一定要指向某个类的同一个实例（即同一个对象）。  
class Diff {  
    public $info = '对象比较';  
}  
  
$obj1 = new Diff();  
$obj2 = $obj1;  
  
echo $obj1 == $obj2 ? '$obj1 == $obj2' : '$obj1 != $obj2';  
br();  
echo $obj1 === $obj2 ? '$obj1 === $obj2' : '$obj1 !== $obj2';  
br();  
hr();  
  
$obj3 = clone $obj1;  
echo $obj1 == $obj3 ? '$obj1 == $obj3' : '$obj1 != $obj3';  
br();  
echo $obj1 === $obj3 ? '$obj1 === $obj3' : '$obj1 !== $obj3';  
br();  
hr();  
  
  
#-----------------------  
# 在php5 的对象编程经常提到的一个关键点是“默认情况下对象是通过引用传递的”。但其实这不是完全正确的。下面通过一些例子来说明。  
# php的引用是别名，就是两个不同的变量名字指向相同的内容。  
# 在php5，一个对象变量已经不再保存整个对象的值。只是保存一个标识符来访问真正的对象内容。  
# 当对象作为参数传递，作为结果返回，或者赋值给另外一个变量，另外一个变量跟原来的不是引用的关系，只是他们都保存着同一个标识符的拷贝，这个标识符指向同一个对象的真正内容。  
  
  
#-----------------------  
# 所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。  
# unserialize()函数能够重新把字符串变回php原来的值。  
# 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。  
class Seo {  
    public $title = 'SEO标题';  
  
    public function getKeyword() {  
        echo 'SEO关键字';  
        br();  
    }  
  
    protected function getDescription() {  
        echo 'SEO描述信息';  
        br();  
    }  
}  
  
$seo = serialize(new Seo());  
var_dump($seo);  
br();  
$seo = unserialize($seo);  
$seo = new Seo();  
echo $seo->title;  
br();  
$seo->getKeyword();  
// $seo->getDescription(); // protected private 类的属性和方法将被过滤  
hr();  
  
  
#-----------------------  
# 什么是命名空间？从广义上来说，命名空间是一种封装事物的方法。  
# 在很多地方都可以见到这种抽象概念。  
#例如，在操作系统中目录用来将相关文件分组，对于目录中的文件来说，它就扮演了命名空间的角色。  
# 具体举个例子，文件 foo.txt 可以同时在目录/home/greg 和 /home/other 中存在，但在同一个目录中不能存在两个 foo.txt 文件。  
# 另外，在目录 /home/greg 外访问 foo.txt 文件时，我们必须将目录名以及目录分隔符放在文件名之前得到 /home/greg/foo.txt。这个原理应用到程序设计领域就是命名空间的概念。  
  
  
#-----------------------  
# 在PHP中，命名空间用来解决在编写类库或应用程序时创建可重用的代码如类或函数时碰到的两类问题  
# 1.用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。  
# 2.为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。  
  
# 名为PHP或php的命名空间，以及以这些名字开头的命名空间（例如PHP\Classes）被保留用作语言内核使用，而不应该在用户空间的代码中使用。  
  
  
#-----------------------  
# 虽然任意合法的PHP代码都可以包含在命名空间中，但只有以下类型的代码受命名空间的影响，它们是：类（包括抽象类和traits）、接口、函数和常量。  
# 命名空间通过关键字namespace 来声明。如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间，除了一个以外：declare关键字。  
# 另外，所有非 PHP 代码包括空白符都不能出现在命名空间的声明之前  
# 另外，与PHP其它的语言特征不同，同一个命名空间可以定义在多个文件中，即允许将同一个命名空间的内容分割存放在不同的文件中。  
  
  
#-----------------------  
# 命名空间层级定义使用\符合分隔，如 namespace MyProject\Sub\Level，该命名空间下定义的常量、类、方法都属于该命名空间  
# 也可以在同一个文件中定义多个命名空间。在同一个文件中定义多个命名空间有两种语法形式。  
  
# 1.定义多个命名空间，简单组合语法。不建议使用这种语法在单个文件中定义多个命名空间，建议使用下面这种方式。  
/**  
 * namespace MyProject;  
 * const PROJECT_NAME = NULL;  
 * class Project {}  
 * function getProjectInfo() {}  
 *  
 * namespace TheyProject;  
 * const PROJECT_NAME = NULL;  
 * class Project {}  
 * function getProjectInfo() {}  
 */  
  
# 2.定义多个命名空间，大括号语法  
/**  
 * namespace MyProject {  
 *     const PROJECT_NAME = NULL;  
 *     class Project {}  
 *     function getProjectInfo() {}  
 * }  
 *  
 * namespace TheyProject {  
 *     const PROJECT_NAME = NULL;  
 *     class Project {}  
 *     function getProjectInfo() {}  
 * }  
 */  
  
# 在实际的编程实践中，非常不提倡在同一个文件中定义多个命名空间。这种方式的主要用于将多个 PHP 脚本合并在同一个文件中。  
# 将全局的非命名空间中的代码与命名空间中的代码组合在一起，只能使用大括号形式的语法。全局代码必须用一个不带名称的 namespace 语句加上大括号括起来  
# 除了开始的declare语句外，命名空间的括号外不得有任何PHP代码。  
  
  
#-----------------------  
# 在文件系统中访问一个文件有三种方式  
/**  
 * 1.相对文件名形式如foo.txt。它会被解析为 currentdirectory/foo.txt，其中 currentdirectory 表示当前目录。因此如果当前目录是 /home/foo，则该文件名被解析为/home/foo/foo.txt。  
 * 2.相对路径名形式如subdirectory/foo.txt。它会被解析为 currentdirectory/subdirectory/foo.txt。  
 * 3.绝对路径名形式如/main/foo.txt。它会被解析为/main/foo.txt。  
 */  
  
# PHP 命名空间中的元素使用同样的原理。例如，类名可以通过三种方式引用  
/**  
 * 1.非限定名称，或不包含前缀的类名称，例如 $a=new foo(); 或 foo::staticmethod();。  
 *   如果当前命名空间是 currentnamespace，foo 将被解析为 currentnamespace\foo。  
 *   如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，则 foo 会被解析为foo。  
 *   警告：如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称会被解析为全局函数名称或常量名称。详情参见 使用命名空间：后备全局函数名称/常量名称。  
 * 2.限定名称,或包含前缀的名称，例如 $a = new subnamespace\foo(); 或 subnamespace\foo::staticmethod();。  
 *   如果当前的命名空间是 currentnamespace，则 foo 会被解析为 currentnamespace\subnamespace\foo。  
 *   如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，foo 会被解析为subnamespace\foo。  
 * 3.完全限定名称，或包含了全局前缀操作符的名称，例如， $a = new \currentnamespace\foo(); 或 \currentnamespace\foo::staticmethod();。  
 *   在这种情况下，foo 总是被解析为代码中的文字名(literal name)currentnamespace\foo。  
 */  
  
# 注意访问任意全局类、函数或常量，都可以使用完全限定名称，例如 \strlen() 或 \Exception 或 \INI_ALL。  
/**  
 * namespace Foo;  
 *  
 * function strlen() {}  
 * const INI_ALL = 3;  
 * class Exception {}  
 *  
 * $a = \strlen('hi');              // 调用全局函数strlen  
 * $b = \INI_ALL;                   // 访问全局常量 INI_ALL  
 * $c = new \Exception('error');    // 实例化全局类 Exception  
 */  
# 注意因为在动态的类名称、函数名称或常量名称中，限定名称和完全限定名称没有区别，因此其前导的反斜杠是不必要的。如下代码  
class classname {  
    function __construct() {  
        echo __METHOD__;  
        br();  
    }  
}  
  
function funcname() {  
    echo __FUNCTION__;  
    br();  
}  
const constname = "global";  
  
$a = 'classname';  
$obj = new $a; // prints classname::__construct  
  
$b = 'funcname';  
$b(); // prints funcname  
  
echo constant('constname'); // prints global  
hr();  
  
# 即将以上代码改写成命名空间后，在调用时使用 \namespaceName\className 和 namespaceName\className 没区别  
  
  
#-----------------------  
# PHP支持两种抽象的访问当前命名空间内部元素的方法，__NAMESPACE__ 魔术常量和namespace关键字。  
# 常量__NAMESPACE__的值是包含当前命名空间名称的字符串。在全局的，不包括在任何命名空间中的代码，它包含一个空的字符串。  
  
  
#-----------------------  
# 所有支持命名空间的PHP版本支持三种别名或导入方式：为类名称使用别名(use关键字)、为接口使用别名或为命名空间名称使用别名。PHP 5.6开始允许导入函数或常量或者为它们设置别名(在use后紧接function或const关键字)。  
# 注意对命名空间中的名称（包含命名空间分隔符的完全限定名称如 Foo\Bar以及相对的不包含命名空间分隔符的全局名称如 FooBar）来说，前导的反斜杠是不必要的也不推荐的，因为导入的名称必须是完全限定的，不会根据当前的命名空间作相对解析。  
# 为了简化操作，PHP还支持在一行中使用多个use语句  
  
# 导入操作是在编译执行的，但动态的类名称、函数名称或常量名称则不是。  
# 另外，导入操作只影响非限定名称和限定名称。完全限定名称由于是确定的，故不受导入的影响。  
  
  
#-----------------------  
# 如果没有定义任何命名空间，所有的类与函数的定义都是在全局空间，与 PHP 引入命名空间概念前一样。在名称前加上前缀 \ 表示该名称是全局空间中的名称，即使该名称位于其它的命名空间中时也是如此。  
  
# 在一个命名空间中，当 PHP 遇到一个非限定的类、函数或常量名称时，它使用不同的优先策略来解析该名称。  
# 类名称总是解析到当前命名空间中的名称。因此在访问系统内部或不包含在命名空间中的类名称时，必须使用完全限定名称  
# 对于函数和常量来说，如果当前命名空间中不存在该函数或常量，PHP 会退而使用全局空间中的函数或常量。  
  
  
#-----------------------  
# 命名空间名称定义  
/**  
 * 非限定名称  
 * 名称中不包含命名空间分隔符的标识符，例如 Foo  
 *  
 * 限定名称  
 * 名称中含有命名空间分隔符的标识符，例如 Foo\Bar  
 *  
 * 完全限定名称  
 * 名称中包含命名空间分隔符，并以命名空间分隔符开始的标识符，例如 \Foo\Bar。 namespace\Foo 也是一个完全限定名称。  
 */  
  
# 名称解析遵循下列规则  
  
/**  
 * 1.对完全限定名称的函数，类和常量的调用在编译时解析。例如 new \A\B 解析为类 A\B。  
 * 2.所有的非限定名称和限定名称（非完全限定名称）根据当前的导入规则在编译时进行转换。例如，如果命名空间 A\B\C 被导入为 C，那么对 C\D\e() 的调用就会被转换为 A\B\C\D\e()。  
 * 3.在命名空间内部，所有的没有根据导入规则转换的限定名称均会在其前面加上当前的命名空间名称。例如，在命名空间 A\B 内部调用 C\D\e()，则 C\D\e() 会被转换为 A\B\C\D\e() 。  
 * 4.非限定类名根据当前的导入规则在编译时转换（用全名代替短的导入名称）。例如，如果命名空间 A\B\C 导入为C，则 new C() 被转换为 new A\B\C() 。  
 * 5.在命名空间内部（例如A\B），对非限定名称的函数调用是在运行时解析的。例如对函数 foo() 的调用是这样解析的：  
 *     1.在当前命名空间中查找名为 A\B\foo() 的函数  
 *     2.尝试查找并调用 全局(global) 空间中的函数 foo()。  
 * 6.在命名空间（例如A\B）内部对非限定名称或限定名称类（非完全限定名称）的调用是在运行时解析的。下面是调用 new C() 及 new D\E() 的解析过程：  
 *  
 *     new C()的解析:  
 *     1.在当前命名空间中查找A\B\C类。  
 *     2.尝试自动装载类A\B\C。  
 *  
 *     new D\E()的解析:  
 *     1.在类名称前面加上当前命名空间名称变成：A\B\D\E，然后查找该类。  
 *     2.尝试自动装载类 A\B\D\E。  
 *  
 *     为了引用全局命名空间中的全局类，必须使用完全限定名称 new \C()。  
 */  
  
# 命名空间典型例子  
  
/**  
 * namespace A;  
 *  
 * use B\D, C\E as F;  
 *  
 * // ------------ 函数调用  
 *  
 * foo(); // 首先尝试调用定义在命名空间"A"中的函数foo()  
 * // 再尝试调用全局函数 "foo"  
 *  
 * \foo(); // 调用全局空间函数 "foo"  
 *  
 * my\foo(); // 调用定义在命名空间"A\my"中函数 "foo"  
 *  
 * F(); // 首先尝试调用定义在命名空间"A"中的函数 "F"  
 * // 再尝试调用全局函数 "F"  
 *  
 * // ------------ 类引用  
 *  
 * new B(); // 创建命名空间 "A" 中定义的类 "B" 的一个对象  
 * // 如果未找到，则尝试自动装载类 "A\B"  
 *  
 * new D(); // 使用导入规则，创建命名空间 "B" 中定义的类 "D" 的一个对象  
 * // 如果未找到，则尝试自动装载类 "B\D"  
 *  
 * new F(); // 使用导入规则，创建命名空间 "C" 中定义的类 "E" 的一个对象  
 * // 如果未找到，则尝试自动装载类 "C\E"  
 *  
 *  
 * new \B(); // 创建定义在全局空间中的类 "B" 的一个对象  
 * // 如果未发现，则尝试自动装载类 "B"  
 *  
 * new \D(); // 创建定义在全局空间中的类 "D" 的一个对象  
 * // 如果未发现，则尝试自动装载类 "D"  
 *  
 *  
 * new \F(); // 创建定义在全局空间中的类 "F" 的一个对象  
 * // 如果未发现，则尝试自动装载类 "F"  
 *  
 * // 调用另一个命名空间中的静态方法或命名空间函数  
 *  
 * B\foo(); // 调用命名空间 "A\B" 中函数 "foo"  
 *  
 * B::foo(); // 调用命名空间 "A" 中定义的类 "B" 的 "foo" 方法  
 * // 如果未找到类 "A\B" ，则尝试自动装载类 "A\B"  
 *  
 * D::foo(); // 使用导入规则，调用命名空间 "B" 中定义的类 "D" 的 "foo" 方法  
 * // 如果类 "B\D" 未找到，则尝试自动装载类 "B\D"  
 *  
 * \B\foo(); // 调用命名空间 "B" 中的函数 "foo"  
 *  
 *  
 * \B::foo(); // 调用全局空间中的类 "B" 的 "foo" 方法  
 * // 如果类 "B" 未找到，则尝试自动装载类 "B"  
 *  
 * // 当前命名空间中的静态方法或函数  
 *  
 *  
 * A\B::foo(); // 调用命名空间 "A\A" 中定义的类 "B" 的 "foo" 方法  
 * // 如果类 "A\A\B" 未找到，则尝试自动装载类 "A\A\B"  
 *  
 * \A\B::foo(); // 调用命名空间 "A\B" 中定义的类 "B" 的 "foo" 方法  
 * // 如果类 "A\B" 未找到，则尝试自动装载类 "A\B"  
 */  
  
  
#-----------------------  
# 生成器允许你在 foreach 代码块中写代码来迭代一组数据而不需要在内存中创建一个数组, 那会使你的内存达到上限，或者会占据可观的处理时间。  
# 相反，你可以写一个生成器函数，就像一个普通的自定义函数一样, 和普通函数只返回一次不同的是, 生成器可以根据需要 yield 多次，以便生成需要迭代的值。  
  
# 一个简单的例子就是使用生成器来重新实现 range() 函数。  
# 标准的 range() 函数需要在内存中生成一个数组包含每一个在它范围内的值，然后返回该数组, 结果就是会产生多个很大的数组。  
# 比如，调用 range(0, 1000000) 将导致内存占用超过 100 MB。  
  
# 做为一种替代方法, 我们可以实现一个 xrange() 生成器, 只需要足够的内存来创建 Iterator 对象并在内部跟踪生成器的当前状态，这样只需要不到1K字节的内存。  
  
# 个生成器函数看起来像一个普通的函数，不同的是普通函数返回一个值，而一个生成器可以yield生成许多它所需要的值（包含之前运算的集合）  
# 一个生成器不可以返回值： 这样做会产生一个编译错误。然而return空是一个有效的语法并且它将会终止生成器继续执行。  
# 在内部会为生成的值配对连续的整型索引，就像一个非关联的数组。  
  
# 如果在一个表达式上下文(例如在一个赋值表达式的右侧)中使用yield，你必须使用圆括号把yield申明包围起来。 例如这样是有效的：$data = (yield $value); 否则将得到一个编译错误  
# Yield可以在没有参数传入的情况下被调用来生成一个 NULL值并配对一个自动的键名。  
  
  
#-----------------------  
# 用户可以用自定义的异常处理类来扩展 PHP 内置的异常处理类。  
# 如果使用自定义的类来扩展内置异常处理类，并且要重新定义构造函数的话，建议同时调用 parent::__construct() 来检查所有的变量是否已被赋值。  
# 当对象要输出字符串的时候，可以重载 __toString() 并自定义输出的样式。  
  
# Exception 对象不能被复制。尝试对 Exception 对象复制 会导致一个 E_ERROR 级别的错误。  
  
  
#-----------------------  
# 在 PHP 中引用意味着用不同的名字访问同一个变量内容。这并不像 C 的指针：例如你不能对他们做指针运算，他们并不是实际的内存地址。替代的是，引用是符号表别名。  
$a = '123';  
$b = & $a;  
# 这意味着 $a 和 $b 指向了同一个变量。  
# $a 和 $b 在这里是完全相同的，这并不是 $a 指向了 $b 或者相反，而是 $a 和 $b 指向了同一个地方。  
# 如果具有引用的数组被拷贝，其值不会解除引用。对于数组传值给函数也是如此。  
# 如果对一个未定义的变量进行引用赋值、引用参数传递或引用返回，则会自动创建该变量。  
  
  
#-----------------------  
# 如果在一个函数内部给一个声明为 global 的变量赋于一个引用，该引用只在函数内部可见。可以通过使用 $GLOBALS 数组避免这一点。  
#　注意在函数调用时没有引用符号——只有函数定义中有。光是函数定义就足够使参数通过引用来正确传递了。  
# 在最近版本的 PHP 中如果把 & 用在 foo(&$a); 中会得到一条警告说“Call-time pass-by-reference”已经过时了。  
function foo(&$var) {  
    $var++;  
}  
  
$a = 5;  
foo($a); // 此处不是 foo(&$a); 并且只能是变量，不能是标量  
echo $a;  
hr();  
  
  
#-----------------------  
# 引用返回 - 引用方法  
# 和参数传递不同，这里必须在两个地方都用 & 符号——指出返回的是一个引用，而不是通常的一个拷贝，同样也指出 $myValue 是作为引用的绑定，而不是通常的赋值。  
# 如果试图这样从函数返回引用：return ($this->value);，这将不会起作用，因为在试图返回一个表达式的结果而不是一个引用的变量。只能从函数返回引用变量——没别的方法。  
function quote() {  
    static $b = 0;  
    $b += 1;  
    echo 'value of $b is: ' . $b;  
    br();  
  
    return $b;  
}  
  
$a = quote(); // 这条语句会输出　$b的值　为１  
$a = 5;  
$a = quote(); // 这条语句会输出　$b的值　为2  
$a =& quote(); // 这条语句会输出　$b的值　为3  // 将返回 &$b 可看作 $a = &$b;  
$a = 5;  
$a = quote(); // 这条语句会输出　$b的值　为6  
hr();  
  
  
#-----------------------  
# 当 unset 一个引用，只是断开了变量名和变量内容之间的绑定。这并不意味着变量内容被销毁了。  
  
# 特殊引用  
# 当用 global $var 声明一个变量时实际上建立了一个到全局变量的引用。也就是说和这样做是相同的：$var =& $GLOBALS["var"];  
# 这意味着，例如，unset $var 不会 unset 全局变量。  
# 在一个对象的方法中，$this 永远是调用它的对象的引用。  
  
  
#-----------------------  
# 超全局变量 — 超全局变量是在全部作用域中始终可用的内置变量  
/**  
 * $GLOBALS     // 一个包含了全部变量的全局组合数组。变量的名字就是数组的键。  
 *              // 与所有其他超全局变量不同，$GLOBALS在PHP中总是可用的。  
 *  
 * $_SERVER     // $HTTP_SERVER_VARS [已弃用] — 服务器和执行环境信息  
 *              // $HTTP_SERVER_VARS 包含着相同的信息，但它不是一个超全局变量。  
 *              // 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。  
 *              // 这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。  
 *  
 * $_GET        // 通过 URL 参数传递给当前脚本的变量的数组。  
 *              // $HTTP_GET_VARS 包含相同的信息， 但它不是一个超全局变量。  
 *              // GET 是通过 urldecode() 传递的。  
 *  
 * $_POST       // $HTTP_POST_VARS [已弃用] — HTTP POST 变量  
 *              // $HTTP_POST_VARS 包含相同的信息，但它不是一个超全局变量。  
 *  
 * $_FILES      // $HTTP_POST_FILES [已弃用] — HTTP 文件上传变量  
 *              // 通过 HTTP POST 方式上传到当前脚本的项目的数组。  
 *              // $HTTP_POST_FILES 包含相同的信息，但它不是一个超全局变量。  
 *  
 * $_COOKIE     // $HTTP_COOKIE_VARS [已弃用] — HTTP Cookies  
 *              // 通过 HTTP Cookies 方式传递给当前脚本的变量的数组。  
 *              // $HTTP_COOKIE_VARS 包含相同的信息，但它不是一个超全局变量。  
 *  
 * $_SESSION    // $HTTP_SESSION_VARS [已弃用] — Session 变量  
 *              // 当前脚本可用 SESSION 变量的数组。更多关于如何使用的信息。  
 *              // $HTTP_SESSION_VARS 包含相同的信息，但它不是一个超全局变量。  
 *  
 * $_REQUEST    // HTTP Request 变量  
 *              // 默认情况下包含了 $_GET，$_POST 和 $_COOKIE 的数组。  
 *              // 以命令行方式运行时，将不包含 argv 和 argc 信息；它们将存在于 $_SERVER 数组。  
 *              // 由于 $_REQUEST 中的变量通过 GET，POST 和 COOKIE 输入机制传递给脚本文件，因此可以被远程用户篡改而并不可信。  
 *  
 * $_ENV        // $HTTP_ENV_VARS [已弃用] — 环境变量  
 *              // 通过环境方式传递给当前脚本的变量的数组。  
 *              // $HTTP_ENV_VARS 包含相同的信息，但它不是一个超全局变量。  
 *  
 */  
  
# 默认情况下，所有的超全局变量都是可用的。但是，有一些指令会影响这种可用性。  
# 如果已经弃用的 register_globals 指令被设置为 on 那么局部变量也将在脚本的全局作用域中可用。例如， $_POST['foo'] 也将以 $foo 的形式存在。  
# 在函数或类方法中，超全局变量不能被用作可变变量。  
  
  
#-----------------------  
# 除超全局变量外的 PHP 预定义变量  
/**  
 * $php_errormsg        // 前一个错误信息  
 *                      // $php_errormsg 变量包含由 PHP 生成的最新错误信息。
 *                      // 这个变量只在错误发生的作用域内可用，并要求 track_errors 配置项开启（默认关闭）  
 *                      // 如果用户定义了错误处理句柄（set_error_handler()）并且返回 FALSE 的时候
 *                      // $php_errormsg 就会被设置。  
 *  
 * $HTTP_RAW_POST_DATA  // 原生POST数据，在 PHP5.6.0已经过时，并不推荐该变量  
 *                      // $HTTP_RAW_POST_DATA 包含 POST 提交的原始数据。  
 *                      // 一般而言，使用 php://input 代替 $HTTP_RAW_POST_DATA。  
 *  
 * $http_response_header// HTTP 响应头  
 *                      // $http_response_header 数组与 get_headers() 函数类似。  
 *                      // 当使用HTTP 包装器时，$http_response_header 将会被 HTTP 响应头信息填充。
 *                      // $http_response_header 将被创建于局部作用域中。  
 *  
 * $argc    // 传递给脚本的参数数目  
 *          // 包含当运行于命令行下时传递给当前脚本的参数的数目。  
 *          // 脚本的文件名总是作为参数传递给当前脚本，因此 $argc 的最小值为 1。  
 *          // 这个变量仅在 register_argc_argv 打开时可用。  
 *  
 * $argv    // 传递给脚本的参数数组  
 *          // 包含当运行于命令行下时传递给当前脚本的参数的数组。  
 *          // 第一个参数总是当前脚本的文件名，因此 $argv[0] 就是脚本文件名。  
 *          // 这个变量仅在 register_argc_argv 打开时可用。  
 */  
  
  
#-----------------------  
# Exception是所有异常的基类。  
/**  
 * 类属性：  
 * message  异常消息内容  
 * code     异常代码  
 * file     抛出异常的文件名  
 * line     抛出异常在该文件中的行号  
 *  
 * 类方法：  
 * getMessage       获取异常消息内容  
 * getPrevious      返回异常链中的前一个异常  
 * getCode          获取异常代码  
 * getFile          获取发生异常的程序文件名称  
 * getLine          获取发生异常的代码在文件中的行号  
 * getTrace         获取异常追踪信息  
 * getTraceAsString 获取字符串类型的异常追踪信息  
 */  
  
  
#-----------------------  
# 套接字上下文选项 — 套接字上下文选项列表  
# 套接字上下文选项可用于所有工作在套接字上的封装协议，像 tcp, http 和 ftp.  
# 用户PHP访问网络的指定的IP地址（IPv4或IPv6其中的一个）和/或 端口号，这个语法是 ip:port.  
  
// 设定连接 IP 和端口  
$opts = array(  
    'socket' => array(  
        'bindto' => '127.0.0.1:80',  
    ),  
);  
  
// 创建上下文  
$context = stream_context_create($opts);  
  
/*  
file_get_contents('http://dev.leon.integle.com', FALSE, $context);  
hr();  
//*/  
  
  
#-----------------------  
# HTTP context 的选项列表  
# 提供给 http:// 和 https:// 传输协议的 context 选项。 transports.  
  
$opts = array(  
    'http' => array(  
        'method' => 'POST',  
        'header' => 'Content-type: application/x-www-form-urlencoded',  
        'content' => http_build_query(array(  
            'name' => 'Leon',  
            'pass' => 'justthink'  
        ))  
    )  
);  
  
// 创建上下文  
$context = stream_context_create($opts);  
/*  
file_get_contents('http://dev.leon.integle.com', FALSE, $context);  
hr();  
//*/  
  
  
#-----------------------  
# FTP context 的选项列表  
# 提供给 http:// 和 https:// 传输协议的 context 选项。 transports.  
$ftp_path = 'ftp://username:password@example.com/example.txt';  
$stream_options = array(  
    'ftp' => array(  
        'overwrite' => TRUE  
    )  
);  
$stream_context = stream_context_create($stream_options);  
/*  
if ($fh = fopen($ftp_path, 'w', 0, $stream_context)) {  
    fputs($fh, 'example contents');  
    fclose($fh);  
} else {  
    echo 'Could not open file.';  
    br();  
}  
hr();  
//*/  
  
  
#-----------------------  
# SSL 上下文选项 — SSL 上下文选项清单  
# ssl:// 和 tls:// 传输协议上下文选项清单。  
  
  
#-----------------------  
# CURL context options — CURL 上下文选项列表  
# CURL 上下文选项在 CURL 扩展被编译（通过 --with-curlwrappers configure选项）时可用  
# 同 HTTP  
  
  
#-----------------------  
# Phar 上下文（context）选项 — Phar 上下文（context）选项列表  
# phar:// 封装（wrapper）的上下文（context）选项。  
  
  
#-----------------------  
# MongoDB 上下文选项  
# 提供给 mongodb:// 传输协议的 context 选项。 transports.  
  
  
#-----------------------  
# 支持的协议和封装协议  
# PHP 带有很多内置 URL 风格的封装协议，可用于类似 fopen()、 copy()、 file_exists() 和 filesize() 的文件系统函数。 除了这些封装协议，还能通过 stream_wrapper_register() 来注册自定义的封装协议。  
# 用于描述一个封装协议的 URL 语法仅支持 scheme://... 的语法。 scheme:/ 和 scheme: 语法是不支持的。  
/**  
 * file://      访问本地文件系统  
 *              文件系统 是 PHP 使用的默认封装协议，展现了本地文件系统。  
 *              当指定了一个相对路径（不以/、\、\\或 Windows 盘符开头的路径）提供的路径将基于当前的工作目录。  
 *              在很多情况下是脚本所在的目录，除非被修改了。 使用 CLI 的时候，目录默认是脚本被调用时所在的目录。  
 *              在某些函数里，例如 fopen() 和 file_get_contents()， include_path 会可选地搜索，也作为相对的路径。  
 *  
 * http://      访问 HTTP(s) 网址  
 *              允许通过 HTTP 1.0 的 GET方法，以只读访问文件或资源。  
 *              HTTP 请求会附带一个 Host: 头，用于兼容基于域名的虚拟主机。  
 *              如果在你的 php.ini 文件中或字节流上下文（context）配置了 user_agent 字符串，它也会被包含在请求之中。  
 *              数据流允许读取资源的 body，而 headers 则储存在了 $http_response_header 变量里。  
 *              如果需要知道文档资源来自哪个 URL（经过所有重定向的处理后）， 需要处理数据流返回的系列响应报头（response headers）。  
 *  
 * ftp://       访问 FTP(s) URLs  
 *              允许通过 FTP 读取存在的文件，以及创建新文件。 如果服务器不支持被动（passive）模式的 FTP，连接会失败。  
 *              打开文件后你既可以读也可以写，但是不能同时进行。  
 *              当远程文件已经存在于 ftp 服务器上，如果尝试打开并写入文件的时候， 未指定上下文（context）选项 overwrite，连接会失败。  
 *              如果要通过 FTP 覆盖存在的文件， 指定上下文（context）的 overwrite 选项来打开、写入。 另外可使用 FTP 扩展来代替。  
 *              如果你设置了 php.ini 中的 from 指令， 这个值会作为匿名（anonymous）ftp 的密码。  
 *  
 * php://       访问各个输入/输出流（I/O streams）  
 *              php:// — 访问各个输入/输出流（I/O streams）  
 *              PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。  
 *              php://stdin、php://stdout 和 php://stderr 允许直接访问 PHP 进程相应的输入或者输出流。  
 *              数据流引用了复制的文件描述符，所以如果你打开 php://stdin 并在之后关了它， 仅是关闭了复制品，真正被引用的 STDIN 并不受影响。  
 *              注意 PHP 在这方面的行为有很多 BUG 直到 PHP 5.2.1。 推荐你简单使用常量 STDIN、 STDOUT 和 STDERR 来代替手工打开这些封装器。  
 *              php://stdin 是只读的， php://stdout 和 php://stderr 是只写的。  
 *  
 *              php://input  
 *              是个可以访问请求的原始数据的只读流。 POST 请求的情况下，最好使用 php://input 来代替 $HTTP_RAW_POST_DATA，因为它不依赖于特定的 php.ini 指令。  
 *              而且，这样的情况下 $HTTP_RAW_POST_DATA 默认没有填充， 比激活 always_populate_raw_post_data 潜在需要更少的内存。  
 *              enctype="multipart/form-data" 的时候 php://input 是无效的  
 *  
 *              php://output  
 *              是一个只写的数据流， 允许你以 print 和 echo 一样的方式 写入到输出缓冲区。  
 *  
 * zlib://      压缩流  
 *              zlib:// -- bzip2:// -- zip:// — 压缩流  
 *  
 * data://      数据（RFC 2397）  
 *  
 * glob://      查找匹配的文件路径模式  
 *              glob:// — 查找匹配的文件路径模式  
 *  
 * phar://      PHP 归档  
 *              phar:// — PHP 归档  
 *  
 * ssh2://      Secure Shell 2  
 *  
 * rar://       RAR  
 *  
 * ogg://       音频流  
 *  
 * expect://    处理交互式的流  
 *              由 expect:// 封装协议打开的数据流 PTY 通过提供了对进程 stdio、stdout 和 stderr 的访问。  
 */  
  
  
#-----------------------  
# http://php.net/manual/zh/security.php  
  
```  
