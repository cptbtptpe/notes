## 网络知识

### 三步握手和四次挥手  
  
#### 三步握手 - 描述一  
  
> 第一次握手：建立连接时，客户端发送 syn 包（ syn=j ）到服务器，并进入 SYN_SEND 状态，等待服务器确认； SYN ：同步序列编号（ Synchronize Sequence Numbers ）。  
>  
> 第二次握手：服务器收到 syn 包，必须确认客户的 SYN （ ack=j+1 ），同时自己也发送一个 SYN 包（ syn=k ），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；  
>  
> 第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=k+1 ），此包发送完毕，客户端和服务器进入 ESTABLISHED （ TCP 连接成功）状态，完成三次握手。  
  
#### 三次握手 - 描述二  
  
> 第一次握手： host1 发送一个 TCP 标志位 SYN=1 、 ACK=0 的数据包给 host2 ，并随机会产生一个 Sequence number=3233.当 host2 接收到这个数据后， host2 由 SYN=1 可知客户端是想要建立连接；  
>  
> 第二次握手： host2 要对客户端的联机请求进行确认，向 host1 发送应答号 ACK=1 、 SYN=1 ，确认号 Acknowledge number=3234 ，此值是 host1 的序列号加 1 ，还会产生一个随机的序列号 Sequence number=36457 ，这样就告诉 host1 可以进行连接；  
>  
> 第三次握手： host1 收到数据后检查 Acknowledge number 是否是 3233+1 的值，以及 ACK 的值是否为 1 ，若为 1 ， host1 会发送 ACK=1 ，确认号码 Acknowledge number=36457 ，告诉 host2, 你的请求连接被确认，连接可以建立。 
  
#### 四次挥手 - 描述一  
  
> 对于一个已经建立的连接， TCP 使用改进的三次握手来释放连接（使用一个带有 FIN 附加标记的报文段）。
>
> TCP 关闭连接的步骤如下：  
>  
> 第一步，当主机 A 的应用程序通知 TCP 数据已经发送完毕时， TCP 向主机 B 发送一个带有 FIN 附加标记的报文段（ FIN 表示英文 finish ）。  
>  
> 第二步，主机 B 收到这个 FIN 报文段之后，并不立即用 FIN 报文段回复主机 A ，而是先向主机 A 发送一个确认序号 ACK ，同时通知自己相应的应用程序：对方要求关闭连接（先发送 ACK 的目的是为了防止在这段时间内，对方重传 FIN 报文段）。  
>  
> 第三步，主机 B 的应用程序告诉 TCP ：我要彻底的关闭连接， TCP 向主机 A 送一个 FIN 报文段。  
>  
> 第四步，主机 A 收到这个 FIN 报文段后，向主机 B 发送一个 ACK 表示连接彻底释放。  

#### 四次挥手  - 描述二  
  
> 第一次挥手：当传输的数据到达尾部时， host1 向 host2 发送 FIN=1 标志位；可理解成， host1 向 host2 说，我这边的数据传送完成了，我准备断开了连接；  
>  
> 第二次挥手：因 TCP 的连接是全双工的双向连接，关闭也是要从两边关闭；当 host2 收到 host1 发来的 FIN=1 的标志位后， host2 不会立刻向 host1 发送 FIND=1 的请求关闭信息，而是先向 host1 发送一个 ACK=1 的应答信息，表示：你请求关闭的请求我已经收到，但我可能还有数据没有完成传送，你再等下，等我数据传输完成了我就告诉你；  
>  
> 第三次挥手： host2 数据传输完成，向 host1 发送 FIN=1 ， host1 收到请求关闭连接的请求后， host1 就明白 host2 的数据已传输完成，现在可以断开连接了，  
>  
> 第四次挥手： host1 收到 FIND=1 后， host1 还是怕由于网络不稳定的原因，怕 host2 不知道他要断开连接，于是向 host2 发送 ACK=1 确认信息进行确认，把自己设置成 TIME_WAIT 状态并启动定时器，如果 host2 没有收到 ACK ， host2 端 TCP 的定时器到达后，会要求 host1 重新发送 ACK ，当 host2 收到 ACK 后， host2 就断开连接；当 host1 等待 2MLS （ 2 倍报文最大生存时间）后，没有收到 host2 的重传请求后，他就知道 host2 已收到了 ACK ，所以 host1 此时才关闭自己的连接。这一点我觉得设计得非常巧妙！

- [x] 认识 TCP 标志位 - 6 种  
  
    `SYN(synchronous 建立联机)`  
    `ACK(acknowledgement 确认)`  
    `PSH(push 传送)`  
    `FIN(finish 结束)`  
    `RST(reset 重置)`  
    `URG(urgent 紧急)`  
  
#### 图解 TCP 与 UDP 的三次握手与四次挥手过程  
![图解 TCP 与 UDP 的三次握手与四次挥手过程][1]  
  
  [1]: https://github.com/jtleon/notes/blob/master/source/tcp.png  

### OSI 七层与 TCP IP 五层网络架构  
  
#### OSI 七层模型  

| OSI 层 | 功能 | 协议 |  
| --- | --- | --- |  
| 应用层 | 文件传输，电子邮件，文件服务，虚拟终端 | TFTP ， HTTP ， SNMP ， FTP ， SMTP ， DNS ， Telnet |  
| 表示层 | 数据格式化，代码转换，数据加密 | 没有协议 |  
| 会话层 | 解除或建立与别的接点的联系 | 没有协议 |  
| 传输层 | 提供端对端的接口 | TCP ， UDP |  
| 网络层 | 为数据包选择路由 | IP ， ICMP ， RIP ， OSPF ， BGP ， IGMP |  
| 数据链路层 | 传输有地址的帧以及错误检测功能 | SLIP ， CSLIP ， PPP ， ARP ， RARP ， MTU |  
| 物理层 | 以二进制数据形式在物理媒体上传输数据 | ISO2110 ， IEEE802 ， IEEE802.2 |  
  
  
#### TCP/IP 五层模型的协议  

| 协议 | 网络设备 |  
| --- | --- |  
| 应用层 | 服务器 |  
| 传输层 | 四层交换机、也有工作在四层的路由器 |  
| 网络层 | 路由器、三层交换机 |  
| 数据链路层 | 网桥（现已很少使用）、以太网交换机（二层交换机）<br>网卡（其实网卡是一半工作在物理层、一半工作在数据链路层） |  
| 物理层 | 中继器、集线器、还有我们通常说的双绞线也工作在物理层 |  
   
> OSI 的基本概念  
  
- OSI 是 Open System Interconnect 的缩写，意为开放式系统互联。  
- OSI 七层参考模型的各个层次的划分遵循下列原则  
    - [x] 同一层中的各网络节点都有相同的层次结构，具有同样的功能。  
    - [x] 同一节点内相邻层之间通过接口（可以是逻辑接口）进行通信。  
    - [x] 七层结构中的每一层使用下一层提供的服务，并且向其上层提供服务。  
    - [x] 不同节点的同等层按照协议实现对等层之间的通信。  
  
- 第一层：物理层（ PhysicalLayer)  
规定通信设备的机械的、电气的、功能的和过程的特性，用以建立、维护和拆除物理链路连接。具体地讲，机械 特性规定了网络连接时所需接插件的规格尺寸、引脚数量和排列情况等；电气特性规定了在物理连接上传输 bit 流时线路上信号电平的大小、阻抗匹配、传输速率 距离限制等；功能特性是指对各个信号先分配确切的信号含义，即定义了 DTE 和 DCE 之间各个线路的功能；规程特性定义了利用信号线进行 bit 流传输的一组 操作规程，是指在物理连接的建立、维护、交换信息是， DTE 和 DCE 双放在各电路上的动作系列。在这一层，数据的单位称为比特（ bit ）。属于物理层定义的典型规范代表包括： EIA/TIA RS-232 、 EIA/TIA RS-449 、 V.35 、 RJ-45 等。  
  
- 第二层：数据链路层（ DataLinkLayer)  
在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧（ Frame ）在信道上无差错的传输，并进行各电路上的动作系列。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。在这一层，数据的单位称为帧（ frame ）。数据链路层协议的代表包括： SDLC 、 HDLC 、 PPP 、 STP 、帧中继等。  
  
- 第三层：网络层  
在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。网络层将数据链路层提供的帧组成数据包，包中封装有网络层包头，其中含有逻辑地址信息源站点和目的站点地址的网络地址。如 果你在谈论一个 IP 地址，那么你是在处理第 3 层的问题，这是“数据包”问题，而不是第 2 层的“帧”。 IP 是第 3 层问题的一部分，此外还有一些路由协议和地 址解析协议（ ARP ）。有关路由的一切事情都在这第 3 层处理。地址解析和路由是 3 层的重要目的。网络层还可以实现拥塞控制、网际互连等功能。在这一层，数据的单位称为数据包（ packet ）。网络层协议的代表包括： IP 、 IPX 、 RIP 、 OSPF 等。  
  
- 第四层：处理信息的传输层  
第 4 层的数据单元也称作数据包（ packets ）。但是，当你谈论 TCP 等具体的协议时又有特殊的叫法， TCP 的数据单元称为段 （ segments ）而 UDP 协议的数据单元称为“数据报（ datagrams ）”。这个层负责获取全部信息，因此，它必须跟踪数据单元碎片、乱序到达的 数据包和其它在传输过程中可能发生的危险。第 4 层为上层提供端到端（最终用户到最终用户）的透明的、可靠的数据传输服务。所为透明的传输是指在通信过程中 传输层对上层屏蔽了通信传输系统的具体细节。传输层协议的代表包括： TCP 、 UDP 、 SPX 等。  
  
- 第五层：会话层  
这一层也可以称为会晤层或对话层，在会话层及以上的高层次中，数据传送的单位不再另外命名，而是统称为报文。会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。如服务器验证用户登录便是由会话层完成的。  
  
- 第六层：表示层  
这一层主要解决拥护信息的语法表示问题。它将欲交换的数据从适合于某一用户的抽象语法，转换为适合于 OSI 系统内部使用的传送语法。即提供格式化的表示和转换数据服务。数据的压缩和解压缩， 加密和解密等工作都由表示层负责。  
  
- 第七层：应用层  
应用层为操作系统或网络应用程序提供访问网络服务的接口。应用层协议的代表包括： Telnet 、 FTP 、 HTTP 、 SNMP 等。  

![网络七层](https://github.com/jtleon/notes/blob/master/source/osi.jpeg)  

### HTTP 名词  
  
#### HTTP
  
> 超文本传输协议（ HTTP ， HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。 1960 年美国人 Ted Nelson 构思了一种通过计算机处理文本信息的方法，并称之为超文本（ hypertext ）, 这成为了 HTTP 超文本传输协议标准架构的发展根基。 Ted Nelson 组织协调万维网协会（ World Wide Web Consortium ）和互联网工程工作小组（ Internet Engineering Task Force ）共同合作研究，最终发布了一系列的 RFC ，其中著名的 RFC 2616 定义了 HTTP 1.1 。  

#### TCP/IP
  
> Transmission Control Protocol/Internet Protocol 的简写，中译名为传输控制协议/因特网互联协议，又名网络通讯协议，是 Internet 最基本的协议、 Internet 国际互联网络的基础，由网络层的 IP 协议和传输层的 TCP 协议组成。 TCP/IP  定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了 4 层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。通俗而言： TCP 负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而 IP 是给因特网的每一台联网设备规定一个地址。  
  
#### IP
  
> IP 层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层--- TCP 或 UDP 层；相反， IP 层也把从 TCP 或 UDP 层接收来的数据包传送到更低层。 IP 数据包是不可靠的，因为 IP 并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏， IP 数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。  
高层的 TCP 和 UDP 服务在接收数据包时，通常假设包中的源地址是有效的。也可以这样说， IP 地址形成了许多服务的认证基础，这些服务相信数据包是从一个有效的主机发送来的。 IP 确认包含一个选项，叫作 IP source routing ，可以用来指定一条源地址和目的地址之间的直接路径。对于一些 TCP 和 UDP 的服务来说，使用了该选项的 IP 包好像是从路径上的最后一个系统传递过来的，而不是来自于它的真实地点。这个选项是为了测试而存在的，说明了它可以被用来欺骗系统来进行平常是被禁止的连接。那么，许多依靠 IP 源地址做确认的服务将产生问题并且会被非法入侵。  

#### TCP
  
> TCP 是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于 TCP 是面向连接的所以只能用于端到端的通讯。  
TCP 提供的是一种可靠的数据流服务，采用“带重传的肯定确认”技术来实现传输的可靠性。 TCP 还采用一种称为“滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。  
如果 IP 数据包中有已经封好的 TCP 数据包，那么 IP 将把它们向‘上’传送到 TCP 层。 TCP 将包排序并进行错误检查，同时实现虚电路间的连接。 TCP 数据包中包括序号和确认，所以未按照顺序收到的包可以被排序，而损坏的包可以被重传。  
TCP 将它的信息送到更高层的应用程序，例如 Telnet 的服务程序和客户程序。应用程序轮流将信息送回 TCP 层， TCP 层便将它们向下传送到 IP 层，设备驱动程序和物理介质，最后到接收方。  
面向连接的服务（例如 Telnet 、 FTP 、 rlogin 、 X Windows 和 SMTP ）需要高度的可靠性，所以它们使用了 TCP 。 DNS 在某些情况下使用 TCP （发送和接收域名数据库），但使用 UDP 传送有关单个主机的信息。  

#### UDP
  
> UDP 是面向无连接的通讯协议， UDP 数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。  
UDP 通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。  
UDP 与 TCP 位于同一层，但它不管数据包的顺序、错误或重发。因此， UDP 不被应用于那些使用虚电路的面向连接的服务， UDP 主要用于那些面向查询---应答的服务，例如 NFS 。相对于 FTP 或 Telnet ，这些服务需要交换的信息量较小。使用 UDP 的服务包括 NTP （网络时间协议）和 DNS （ DNS 在进行区域传输的时候使用 TCP 协议，其它时候则使用 UDP 协议）。  
欺骗 UDP 包比欺骗 TCP 包更容易，因为 UDP 没有建立初始化连接（也可以称为握手）（因为在两个系统间没有虚电路），也就是说，与 UDP 相关的服务面临着更大的危险。  

#### ICMP
  
> ICMP 与 IP 位于同一层，它被用来传送 IP 的控制信息。它主要是用来提供有关通向目的地址的路径信息。 ICMP 的 'Redirect' 信息通知主机通向其他系统的更准确的路径，而‘ Unreachable ’信息则指出路径有问题。另外，如果路径不可用了， ICMP 可以使 TCP 连接‘体面地’终止。 PING 是最常用的基于 ICMP 的服务。  

#### 通讯端口
  
> TCP 和 UDP 服务通常有一个客户/服务器的关系，例如，一个 Telnet 服务进程开始在系统上处于空闲状态，等待着连接。用户使用 Telnet 客户程序与服务进程建立一个连接。客户程序向服务进程写入信息，服务进程读出信息并发出响应，客户程序读出响应并向用户报告。因而，这个连接是双工的，可以用来进行读写。  
两个系统间的多重 Telnet 连接是如何相互确认并协调一致呢？ TCP 或 UDP 连接唯一地使用每个信息中的如
> 
> 下四项进行确认：  
>
> > 源 IP 地址 发送包的 IP 地址。  
> > 目的 IP 地址 接收包的 IP 地址。  
> > 源端口 源系统上的连接的端口。  
> > 目的端口 目的系统上的连接的端口。  
>   
> 端口是一个软件结构，被客户程序或服务进程用来发送和接收信息。一个端口对应一个 16 比特的数。服务进程通常使用一个固定的端口，例如， SMTP 使用 25 、 Xwindows 使用 6000 。这些端口号是‘广为人知’的，因为在建立与特定的主机或服务的连接时，需要这些地址和目的地址进行通讯。  

#### 数据格式
  
> 数据帧：帧头 + IP 数据包 + 帧尾 （帧头包括源和目标主机 MAC 初步地址及类型，帧尾是校验字）  
IP 数据包： IP 头部 + TCP 数据信息（ IP 头包括源和目标主机 IP 地址、类型、生存期等）  
TCP 数据信息： TCP 头部+实际数据 (TCP 头包括源和目标主机端口号、顺序号、确认号、校验字等）  

#### IP 地址
  
> 在 Internet 上连接的所有计算机，从大型机到微型计算机都是以独立的身份出现，我们称它为主机。为了实现各主机间的通信，每台主机都必须有一个唯一的网络地址。就好像每一个住宅都有唯一的门牌一样，才不至于在传输资料时出现混乱。  
Internet 的网络地址是指连入 Internet 网络的计算机的地址编号。所以，在 Internet 网络中，网络地址唯一地标识一台计算机。  
我们都已经知道， Internet 是由几千万台计算机互相连接而成的。而我们要确认网络上的每一台计算机，靠的就是能唯一标识该计算机的网络地址，这个地址就叫做 IP （ Internet Protocol 的简写）地址，即用 Internet 协议语言表示的地址。  
在 Internet 里， IP 地址是一个 32 位的二进制地址，为了便于记忆，将它们分为 4 组，每组 8 位，由小数点分开，用四个字节来表示，而且，用点分开的每个字节的数值范围是 0~255 ，如 202.116.0.1 ，这种书写方法叫做点数表示法。  

#### URG
  
> 此标志表示 TCP 包的紧急指针域（后面马上就要说到）有效，用来保证 TCP 连接不被中断，并且督促中间层设备要尽快处理这些数据；  

#### ACK
  
> 此标志表示应答域有效，就是说前面所说的 TCP 应答号将会包含在 TCP 数据包中；有两个取值： 0 和 1 ，为 1 的时候表示应答域有效，反之为 0 ；  

#### PSH
  
> 这个标志位表示 Push 操作。所谓 Push 操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队；  

#### RST
  
> 这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；  
  
#### SYN
  
> 表示同步序号，用来建立连接。 SYN 标志位和 ACK 标志位搭配使用，当连接请求的时候， SYN=1 ， ACK=0 ；连接被相应的时候， SYN=1 ， ACK= 1 ；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有 SYN 的数据包，如果对方主机响应了一个数据包回来，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行 TCP 三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行 TCP 的三次握手；  
  
#### FIN
  
> 表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送 FIN 标志位的 TCP 数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。当一个 FIN 标志的 TCP 数据包发送到一台计算机的特定端口，如果这台计算机响应了这个数据，并且反馈回来一个 RST 标志的 TCP 包，就表明这台计算机上没有打开这个端口，但是这台计算机是存在的；如果这台计算机没有反馈回来任何数据包，这就表明，这台被扫描的计算机存在这个端口。  

> 在 TCP 层，有个 FLAGS 字段，这个字段有以下几个标识： SYN, FIN, ACK, PSH, RST, URG. 其中，对于我们日常的分析有用的就是前面的五个字段。  
> 
> 它们的含义是： SYN 表示建立连接， FIN 表示关闭连接， ACK 表示响应， PSH 表示有 DATA 数据传输， RST 表示连接重置。其中， ACK 是可能与 SYN ， FIN 等同时使用的，比如 SYN 和 ACK 可能同时为 1 ，它表示的就是建立连接之后的响应，如果只是单个的一个 SYN ，它表示的只是建立连接。 TCP 的几次握手就是通过这样的 ACK 表现出来的。但 SYN 与 FIN 是不会同时为 1 的，因为前者表示的是建立连接，而后者表示的是断开连接。 RST 一般是在 FIN 之后才会出现为 1 的情况，表示的是连接重置。一般地，当出现 FIN 包或 RST 包时，我们便认为客户端与服务器端断开了连接；而当出现 SYN 和 SYN ＋ ACK 包时，我们认为客户端与服务器建立了一个连接。 PSH 为 1 的情况，一般只出现在 DATA 内容不为 0 的包中，也就是说 PSH 为 1 表示的是有真正的 TCP 数据包内容被传递。 TCP 的连接建立和连接关闭，都是通过请求－响应的模式完成的。  

